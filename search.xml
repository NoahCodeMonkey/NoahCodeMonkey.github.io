<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[我的Java学习之旅二]]></title>
    <url>%2F2019%2F06%2F13%2F%E6%88%91%E7%9A%84Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[这一篇内容还是挺杂的，有异常、一些常用类、集合框架等，因为学过一些基础，不太熟悉但有印象所以就不像写初学新知识文章那样丰富了，我会记一些主要的知识点，容易记混或者已经记混的知识点，新知识点这些 知识点 异常抛出 throw 将产生的异常抛出(动作) throws 声明将要抛出何种类型的异常(声明) 代码：12345public void 方法名(参数列表) throws 异常列表&#123; //调用会抛出异常的方法或者: throw new Exception(); &#125; 异常的实际应用中的经验与总结 处理运行时异常时，采用逻辑去合理规避同时雇主try-catch处理 在多重catch块后面，可以加一个cath(Exception)来处理可能会被遗漏的异常 对于不确定的代码，也可以加上try-catch来处理潜在的异常 尽量去处理异常，切忌知识简单的调用printStackTrace()去打印输出 具体如何处理异常，要根据不同的业务需求和异常类型去决定 尽量添加finally语句块去释放占用的资源 字符串 多次出现的字符常量，Java编译程序只创建一个，所以当两个字符常量相等的话，判断他们的地址是相同的 代码 12345String s1="NoahCode";String s2="NoahCode";System.out.println(s1==s2);控制台输出：true 通过 String s1=”爱慕课”; 声明了一个字符串对象， s1 存放了到字符串对象的引用，在内存中的存放引用关系如下图所示： 然后通过 s1=”欢迎来到：”+s1; 改变了字符串 s1 ，其实质是创建了新的字符串对象，变量 s1 指向了新创建的字符串对象，如下图所示： 一旦一个字符串在内存中创建，则这个字符串将不可改变。如果需要一个可以改变的字符串，我们可以使用StringBuffer或者StringBuilder 每次 new 一个字符串就是产生一个新的对象，即便两个字符串的内容相同，使用 ”==” 比较时也为 ”false” ,如果只需比较内容是否相同，应使用 ”equals()” 方法 String类的常用方法 注意点 字符串 str 中字符的索引从0开始，范围为 0 到 str.length()-1 使用 indexOf 进行字符或字符串查找时，如果匹配返回位置索引；如果没有匹配结果，返回 -1 使用 substring(beginIndex , endIndex) 进行字符串截取时，包括 beginIndex 位置的字符，不包括 endIndex 位置的字符 到现在还在搞混的知识点 获取数组，字符串，集合的大小 如果是数组的话：数组.length属性； 如果是字符串的话：字符串.length()方法； 如果是集合的话：集合.size()方法； ==和equals 基本数据类型，也称原始数据类型。（byte,short,char,int,long,float,double,boolean） 它们之间的比较，应用双等号（==）,比较的是他们的值。 复合数据类型(类) 当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。 JAVA当中所有的类都是继承于Object这个基类的，在Object中的基类中定义了一个equals的方法，这个方法的初始行为是比较对象的内存地 址，但在一些类库当中这个方法被覆盖掉了，如String,Integer,Date在这些类当中equals有其自身的实现，而不再是比较类在堆内存中的存放地址了。 对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是基于他们在内存中的存放位置的地址值的，因为Object的equals方法也是用双等号（==）进行比较的，所以比较后的结果跟双等号（==）的结果相同。 代码案例： 1234567891011121314151617181920 public class HelloWorld &#123; public static void main(String[] args) &#123;// 定义一个字符串String s = "aljlkdsflkjsadjfklhasdkjlflkajdflwoiudsafhaasdasd"; // 出现次数int num = 0; // 循环遍历每个字符，判断是否是字符 a ，如果是，累加次数 for (int i=0;i&lt;s.length();i++) &#123; // 获取每个字符，判断是否是字符a if (s.charAt(i)=='a') &#123; // 累加统计次数 num++; &#125; &#125;System.out.println("字符a出现的次数：" + num); &#125; &#125; StringBuilder类常用方法 测试题 功能：将一个由英文字母组成的字符串转换成指定格式—从右边开始每三个字母用逗号分隔的形式 代码： 1234567891011121314 public class HelloWorld &#123; public static void main(String[] args) &#123;// 创建一个空的StringBuilder对象StringBuilder str=new StringBuilder();// 追加字符串str.append("jaewkjldfxmopzdm"); // 从后往前每隔三位插入逗号for(int i=str.length();i&gt;=0;i-=3)&#123; str.insert(i,",");&#125;// 将StringBuilder对象转换为String对象并输出System.out.print(str.toString()); &#125; &#125; 这道题目我居然想了半天，看了别人的代码，才想到了解决方案,我就是迟迟想不到for可以使用i-=3;脑子中一直卡着i–;for循环里面判断(str.length()-i)/3==0的时候insert，可是这样的话他就会把新加入的’,’也当做一位然后就错了 包装类 基本类型和包装类之间对应关系 Integer包装类的构造方法: Integer包装类中最常用方法: 基本类型和包装类之间的转换 装箱 把基本类型转换成包装类，使其具有对象的性质，又可分为手动装箱和自动装箱 手动装箱 代码： 1Integer i1 = new Integer(10); 自动装箱 代码： 1Integer i2 = 10; 拆箱 和装箱相反，把包装类对象装换成基本类型的值，又可分为手动拆箱和自动拆箱 手动拆箱 代码： 1int i3 = i1.intValue(); 自动拆箱 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 int i4 = i2; ``` 8. 基本类型和字符串之间的转换 1. 基本类型转换为字符串有三种方法： 1. 使用包装类的toString()方法 2. 使用String类的valueOf()方法 3. 用一个空字符串加上基本类型得到的就是基本类型数据对应的字符串 2. 字符串转换成基本类型有两种方法 1. 调用包装类的parseXxx静态方法 2. 调用包装类的valueOf()方法转换为基本类型的包装类，会自动拆箱9. 使用Date和SimpleDateFormat类表示时间 1. Date类 * import java.util.data;(它所在的包) * Date 类的默认无参构造方法创建出的对象就代表当前时间，我们可以直接输出Date对象显示当前的时间，显示结果如下： ![诶呀，图片加载出了点问题！](https://noahcodemonkey.top/images/img/我的Java学习之旅二/img06.jpg) * 其中， Wed 代表 Wednesday (星期三)， Jun 代表 June (六月)， 11 代表 11 号， CST 代表 China Standard Time (中国标准时间，也就是北京时间，东八区)。 * 从上面的输出结果中，我们发现，默认的时间格式不是很友好，与我们日常看到的日期格式不太一样，如果想要按指定的格式进行显示，如 2014-06-11 09:22:30，这时候我们就可以可以使用 SimpleDateFormat 来对日期时间进行格式化，如可以将日期转换为指定格式的文本，也可将文本转换为日期 2. SimpleDateFormat类 * import java.text.SimpleDateFormat;(它的包的位置) * 使用 format() 方法将日期转换为指定格式的文本 ![诶呀，图片加载出了点问题！](https://noahcodemonkey.top/images/img/我的Java学习之旅二/img07.jpg) * 使用 parse() 方法将文本转换为日期 ![诶呀，图片加载出了点问题！](https://noahcodemonkey.top/images/img/我的Java学习之旅二/img08.jpg) * 注意： 1. 调用 SimpleDateFormat 对象的 parse() 方法时可能会出现转换异常，即 ParseException ，因此需要进行异常处理 2. 使用 Date 类时需要导入 java.util 包，使用 SimpleDateFormat 时需要导入 java.text 包10. Calendar类的应用 * import java.util.Calendar; * java.util.Calendar 类是一个抽象类，可以通过调用 getInstance() 静态方法获取一个 Calendar 对象，此对象已由当前日期时间初始化，即默认代表当前时间:Calendar c = Calendar.getInstance(); * 想要获取年、月、日、时间等信息，我们可以在创建完对象后使用get()方法来获取日期时间信息，参数为需要获得的字段的值：Calendar.Year...(如图所示) ![诶呀，图片加载出了点问题！](https://noahcodemonkey.top/images/img/我的Java学习之旅二/img09.jpg) * Calendar 类提供了 getTime() 方法，用来获取 Date 对象，完成 Calendar 和 Date 的转换，还可通过 getTimeInMillis() 方法，获取此 Calendar 的时间值，以毫秒为单位(如图所示) ![诶呀，图片加载出了点问题！](https://noahcodemonkey.top/images/img/我的Java学习之旅二/img010.jpg)11. Math类操作数据 * 常用的方法： ![诶呀，图片加载出了点问题！](https://noahcodemonkey.top/images/img/我的Java学习之旅二/img011.jpg)12. Java中的集合框架 ![诶呀，图片加载出了点问题！](https://noahcodemonkey.top/images/img/我的Java学习之旅二/img012.png) 1. 通过迭代器遍历List ```Java public void testIterator()&#123; Iterator it = coursesToSelect.iterator(); while(it.hasNext())&#123; Course cr = (Course)it.next(); System.out.println("课程:"+cr.id+":"+cr.name); &#125; &#125; 对集合进行排序 import java.util.Collections; 使用Collections.sort();进行排序 Comparable和Comparator Comparable接口–可比较的 实现该接口表示：这个类的实例可以比较大小，可以进行自然排序 定义了默认的比较规则 其实现类需要实现compareTo()方法 compareTo()方法返回证书表示大，负数表示小，0表示相等 Comparator接口–比较工具接口 用一定以临时比较规则，而不是默认比较规则 其实现类需要实现compare()方法 Comparator和Comparable都是Java集合框架的成员 到头来就是要多写代码，多看API，有很多有意思的方法，虽然很少用，但是能减轻我们的代码量，要去认识它们，想到它们，熟悉它们]]></content>
      <categories>
        <category>Java</category>
        <category>入门</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Java</tag>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的Java学习之旅一]]></title>
    <url>%2F2019%2F06%2F12%2F%E6%88%91%E7%9A%84Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%B8%80%2F</url>
    <content type="text"><![CDATA[开始重新学习Java知识，最终目标是Java的后端开发，从头开始，一点一滴，不急不躁。 知识点 源文件的编译过程 源文件(.java) -&gt; compiler(编译器) -&gt; 字节码文件(.class) -&gt; interpreter(解释器) -&gt; 软件(program) 随机数的创建 脑子中一直只有创建Random对象，然后使用随机数 12 Random random = new Random();nums[i] = random.nextInt(100); 现在才知道Math类中也有random随机数1nums[i]=(int)(Math.random()*100); 静态初始化块只在类加载时执行，且只会执行一次，同时静态初始化块只能给静态变量赋值，不能初始化普通的成员变量 this this关键字代表当前对象 this.属性 操作当前对象的属性 this.方法 调用当前对象的方法 封装对象的属性的时候，经常会使用this关键字 创建内部类对象：内部类 对象名 = 外部类对象.new 内部类( ) 内部类的使用注意点 外部类是不能直接使用内部类的成员和方法滴 如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可以使用 this 关键字 静态内部类 静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问 如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员 创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名= new 内部类(); 方法内部类 由于方法内部类不能在外部类的方法以外的地方使用，因此方法内部类不能使用访问控制符和 static 修饰符 final 修饰的类不可被继承 super关键字：在对象的内部使用，可以代表父类对象 若要访问父类的属性：super.age 若要访问父类的方法：super.eat() super的应用： 子类的构造的过程当中必须调用其父类的构造方法 如果子类的构造方法中没有显示调用父类的构造方法，则系统会默认调用父类无参的构造方法 如果显示的调用构造方法，必须在子类的构造方法的第一行 如果子类构造方法中既没有显示调用父类的构造方法，而父类有没有无参的构造方法，则编译错误 包的命名规范：包名应该全是小写字母拼写 object类的使用 toString()方法 在object类里面定义toString()方法的时候返回的对象的哈希code码(对象地址字符串) 我们可以通过重写toString()方法表示出对象的属性 equals()方法 比较的是对象的引用是否只想同一块内存地址 若要比较两个对象的值是否相同，我们需要重写equals方法 PS:在生成的重写equals方法中有一个getClass()方法，下面有一张图片方便我们理解 差别： 类的对象：主要关注的是类的对象的值的信息 类对象：主要关注的是类的属性的信息 多态 引用多态 父类的引用可以指向本类的对象 代码：1Animal a1 = new Animal(); 父类的引用可以指向子类的对象 代码：1Animal a2 = new Dog(); 方法多态 创建本类对象时，调用的方法为本类方法 代码：12Animal a1 = new Animal();a1.eat();//此方法为父类Animal的eat方法 创建子类对象时，调用的方法为子类重写的方法或者继承的方法 代码：12Animal a2 = new Dog();a1.eat();//此方法为子类Dog的eat方法 引用类型的转换 向上类型转换(隐式/自动类型转换)，是小类型到大类型的转换 没有风险，可以直接转换 代码： 12Dog dog = new Dog();Animal animal = dog; 向下类型转换(强制转换)，是大类型到小类型 有风险 代码： 123Dog dog = new Dog();Animal animal = dog;Dog dog2 = (Dog)animal; instanceof运算符，来解决引用对象的类型，避免类型转换的安全性问题 自我总结：使用起来就像try catch 代码： 12345if(animal instanceof Dog)&#123; Dog dog2 = (Dog)animal;&#125;else&#123; System.out.println("无法进行类型转换");&#125; 抽象类 应用场景 在某些情况下，某个父类知识知道其子类应该包含怎样的方法，但无法准确知道这些子类如何实现这些方法 从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为子类的模版，从而避免了子类设计的随意性 作用： 限制规定子类必须实现某些方法，但不关注实现细节 使用规则： abstract 定义抽象类 abstract定义抽象方法，只有声明，不需要实现 包含抽象方法的类是抽象类 抽象类中可以包含普通的方法，也可以没有抽象方法 抽象类不能直接创建，可以定义引用变量 接口 (负责功能的拓展) 接口的概念 接口可以理解为一种特殊的类，由全局常量和公共的抽象方法组成 类是一种具体实现体，而接口定义了某一批类所需要遵守的规范，接口不关心这些类的内部数据，也不关心这些类里的方法的实现细节，她只规定这些类里必须提供某些方法 接口定义 和类定义不同，定义接口不再使用class关键字，而是使用interface关键字 接口就是用来被继承、被实现的，修饰符一般建议用public 注意：不能使用private和protected修饰接口 项目的分析 数据模型分析 通过对像是世界的事与物主要特征的分析、抽象，为信息系统提供的 实施提供数据存储的数据结构以及相应的约束 数据结构组成：操作(方法)、属性 业务模型分析 在设计应用程序之前，应该明确该应用程序必须执行哪些任务 分析业务需求是应该用程序开发中最重要的步骤之一 确认业务需求的目的在于创建一个能同事满足零售商和消费者需要的解决方案 显示和流程分析 显示：用户可以看到的信息提示界面 流程：显示信息的执行过、步骤 习题测试最后一章视频中老师给我们一个小任务让我们去完成，我完全用的是老的知识去完成了这个项目，并没有使用什么封装啊，多态啊什么的，感觉自己真的对于这块的知识不是很熟悉，遇到问题基本想不到要去用到他们，我想以后更多的练习来提升自己的编码思维]]></content>
      <categories>
        <category>Java</category>
        <category>入门</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Java</tag>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的Spring学习之旅二]]></title>
    <url>%2F2019%2F06%2F07%2F%E6%88%91%E7%9A%84Spring%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[学习内容 Spring中IOC的常用注解 案例使用XML方式和注解方式实现单标的CURD操作 持久层技术选择：dbutils 改造基于注解的IOC案例，使用纯主机的方式实现 spring的一些新注解的使用 Spring和Junit整合 知识点注意：用于告知Spring在创建容器时要扫描的包，配置所需要的标签不是在bean的约束中，而是一个名称为context名称空间和约束中 代码如下： 1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:component-scan base-package="com.noahcode"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; Spring中IOC的常用注解 用于创建对象的 他们的作用就和在XML配置文件中编写一个&lt;bean&gt;标签实现的功能是一样的 @Component 用于把当前对象存入Spring容器中 属性： value：用于指定bean的id。当我们不写时，它的默认值是当前类名，且首字母改小写 @Controller:一般用在表现层 @Service：一般用在业务层 @Repository：一般用于持久层 以上三个注解他们的作用和属性与Component是一模一样的。他们三个是Spring框架为我们提供明确的三层使用的注解，使我们的三层对象更加清晰 用于注入数据的 他们的作用就和在XML配置文件中的&lt;bean&gt;标签中写一个&lt;property&gt;标签的作用是一样的 @Autowired 作用： 自动按照类型注入，只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配就可以注入成功； 如果IOC容器中没有任何bean的类型和要注入的数据类型匹配就报错； 如果IOC中有多个类型匹配时，首先先按照数据类型圈定出来匹配的对象，然后再使用变量名称作为bean的id在圈定出来的对象中进项匹配，如果有就注入成功，如果没有就报错。 出现位置： 可以是变量上，也可以是方法上 细节： 在使用注解注入时，set方法就不是必须的了。 @Qualifier: 作用：在按照类中注入的基础之上再按照名称注入，他在给类成员注入时不能单独使用，但是在给方法参数注入时可以 属性： value：用于指定注入bean的id @Resource 作用：直接按照bean的id注入，他可以独立使用 属性： name：用于指定bean的id 以上三种注解都只能注入其他bean类型的数据，而基本类型和String类型无法使用上述注解实现，另外，集合类型的注入只能通过XML来实现。 @Value 作用：用于注入基本类型和String类型的数据 属性： value：用于指定数据的值，它可以使用Spring中的SpEL(也就是Spring的el表达式) SpEL的写法：${表达式} 用于改变作用范围的 他们的作用就和在&lt;bean&gt;标签中使用scope属相实现是一样的 @Scope 作用：用于指定bean的作用范围 属性： value：指定范围的取值。常用取值：singleton(单例/默认)prototype(多例) 和生命周期相关的(仅需了解) 他们的作用就和在&lt;bean&gt;标签中使用init-method和destroy-methode属性的作用是一样的 @PostConstruct 作用：用于指定初始化方法 @PreDestroy 作用：用于指定销毁方法 JDBC项目代码记录(xml配置版) pom.xml 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.noahcode&lt;/groupId&gt; &lt;artifactId&gt;day01_spring&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbutils&lt;/groupId&gt; &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; src/main/java/com/noahcode/domain/Account 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.noahcode.domain;import java.io.Serializable;/** * 账户的实体类 */public class Account implements Serializable &#123; private Integer id; private String name; private float money; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public float getMoney() &#123; return money; &#125; public void setMoney(float money) &#123; this.money = money; &#125; @Override public String toString() &#123; return "Account&#123;" + "id=" + id + ", name='" + name + '\'' + ", money=" + money + '&#125;'; &#125;&#125; src/main/java/com/noahcode/service/IAccountService 12345678910111213141516171819202122232425262728293031323334353637383940package com.noahcode.service;import com.noahcode.domain.Account;import java.util.List;/** * 账户的业务层接口 */public interface IAccountService &#123; /** * 查询所有 * @return */ List&lt;Account&gt; findAllAccount(); /** * 查询一个 * @return */ Account findAccountByID(Integer accountId); /** * 保存 * @param account */ void saveAccount(Account account); /** * 更新 * @param account */ void updateAccount(Account account); /** * 删除 * @param accountId */ void deleteAccount(Integer accountId);&#125; src/main/java/com/noahcode/service/impl/AccountService 123456789101112131415161718192021222324252627282930313233343536373839package com.noahcode.service.impl;import com.noahcode.dao.IAccountDao;import com.noahcode.domain.Account;import com.noahcode.service.IAccountService;import java.util.List;/** * 账户的业务层实现类 */public class AccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao; public void setAccountDao(IAccountDao accountDao) &#123; this.accountDao = accountDao; &#125; public List&lt;Account&gt; findAllAccount() &#123; return accountDao.findAllAccount(); &#125; public Account findAccountByID(Integer accountId) &#123; return accountDao.findAccountByID(accountId); &#125; public void saveAccount(Account account) &#123; accountDao.saveAccount(account); &#125; public void updateAccount(Account account) &#123; accountDao.updateAccount(account); &#125; public void deleteAccount(Integer accountId) &#123; accountDao.deleteAccount(accountId); &#125;&#125; src/main/java/com/noahcode/dao/IAccountDao 12345678910111213141516171819202122232425262728293031323334353637383940package com.noahcode.dao;import com.noahcode.domain.Account;import java.util.List;/** * 账户的持久层 */public interface IAccountDao&#123; /** * 查询所有 * @return */ List&lt;Account&gt; findAllAccount(); /** * 查询一个 * @return */ Account findAccountByID(Integer accountId); /** * 保存 * @param account */ void saveAccount(Account account); /** * 更新 * @param account */ void updateAccount(Account account); /** * 删除 * @param accountId */ void deleteAccount(Integer accountId);&#125; src/main/java/com/noahcode/dao/impl/AccountDao 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.noahcode.dao.impl;import com.noahcode.dao.IAccountDao;import com.noahcode.domain.Account;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import java.sql.SQLException;import java.util.List;/** * 账户的持久层实现类 */public class AccountDao implements IAccountDao &#123; private QueryRunner runner; public void setRunner(QueryRunner runner) &#123; this.runner = runner; &#125; public List&lt;Account&gt; findAllAccount() &#123; try &#123; return runner.query("select * from account",new BeanListHandler&lt;Account&gt;(Account.class)); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; public Account findAccountByID(Integer accountId) &#123; try &#123; return runner.query("select * from account where id = ?",new BeanHandler&lt;Account&gt;(Account.class),accountId); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; public void saveAccount(Account account) &#123; try &#123; runner.update("insert into account(name,money)values(?,?)",account.getName(),account.getMoney()); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; public void updateAccount(Account account) &#123; try &#123; runner.update("update account set name=?,money=? where id=?",account.getName(),account.getMoney(),account.getId()); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; public void deleteAccount(Integer accountId) &#123; try &#123; runner.update("delete from account where id=?",accountId); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; /src/main/java/resources/bean.xml 123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!--配置Service对象--&gt; &lt;bean id="accountService" class="com.noahcode.service.impl.AccountServiceImpl"&gt; &lt;property name="accountDao" ref="accountDao"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置Dao对象--&gt; &lt;bean id="accountDao" class="com.noahcode.dao.impl.AccountDao"&gt; &lt;property name="runner" ref="runner"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置QueryRunner对象--&gt; &lt;bean id="runner" class="org.apache.commons.dbutils.QueryRunner" scope="prototype"&gt; &lt;constructor-arg name="ds" ref="dataSource"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!--配置数据源对象--&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;!--连接数据库的必备信息--&gt; &lt;property name="driverClass" value="com.mysql.cj.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/eesy"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="5945"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; /src/test/java/com/noahcode/test/AccountServiceTest 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.noahcode.test;import com.noahcode.domain.Account;import com.noahcode.service.IAccountService;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import javax.sound.midi.Soundbank;import java.util.List;/** * 使用Junit单元测试，测试我们的配置 */public class AccountServiceTest &#123; //1.获取容器 ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); //2.得到业务层对像 IAccountService as = ac.getBean("accountService", IAccountService.class); @Test public void testFindAll() &#123; List&lt;Account&gt; accounts = as.findAllAccount(); for (Account account : accounts) &#123; System.out.println(account); &#125; &#125; @Test public void testFindOne() &#123; Account account=as.findAccountByID(1); System.out.println(account); &#125; @Test public void testSave() &#123; Account account=new Account(); account.setName("test"); account.setMoney(4); as.saveAccount(account); &#125; @Test public void testUpdate() &#123; Account account=as.findAccountByID(2); account.setName("Noah"); account.setMoney(10); as.updateAccount(account); &#125; @Test public void testDelete() &#123; as.deleteAccount(2); &#125;&#125; 知识点Spring中的新注解 @Configuration 作用：制定当前类是一个配置类 细节： 当配置类作为AnnotationConfigApplicationContext对象创建的参数时，该注解可以不写 @ComponentScan 作用：用于通过注解指定Spring在创建容器是要扫描的包 属性： value：他和basePackages的作用是一样的，都是用于指定创建容器是要扫描的包。 我们使用此注解等同于在xml中配置了： 1&lt;context:component-scan base-package="com.noahcode"&gt;&lt;/context:component-scan&gt; @Bean 作用：用于把当前方法的返回值作为bean对象存入Spring的IOC容器中 属性： name：用于指定bean的id，当不写时，默认值是当前方法的名称 细节： 当我们使用注解配制方法时，如果方法有参数，spring框架回去容器中查找有没有可用的bean对象 查找方式和@Autowired猪似的作用是一样的 @Import 作用：用于导入其他的配置类 属性： value：用于指定其他配置类的字节码。 当我们使用Import注解的泪就是父配置类，而导入的都是子配置类 @PropertySource 作用：用于指定Properties文件的位置 属性： value：指定文件的名称和路径 关键字：classpath：表示类路径下 补充：junit的一点基础知识 应用程序的入口 main方法 junit单元测试中，没有main方法也能执行 junit集成了一个main方法 该方法就会判断当前测试类中哪些方法有@Test注解 junit就会让有@Test主机的方法执行 junit不会管我们是否采用Spring框架 在执行测试方法时，junit根本不知道我们是不是使用了Spring框架 所以也就不会为我们读取配置文件/配置类创建Spring核心容器 以上三点可知：当测试方法执行时，没有IOC容器，就算写了Autowired注解，也无法实现注入 Spirng整合Junit的配置 导入Spring整合Junit的jar包(坐标) 使用Junit提供的一个注解把原有的main方法替换了，替换成Spinrg提供的 @Runwith 告知Spring的运行器，Spinrg和IOC创建时基于XML还是注解的，并且说明位置 @ContextConfiguration location:指定XML文件的位置，加上classpath关键字，表示在类路径下 classes：指定注解类所在地位置 注：当我们使用Spinrg 5.x版本的时候，要求Junit的jar包必须是4.12及以上 JDBC项目代码记录(完全注解版)+Spring整合Junit版 /src/main/java/com/noahcode/config/SpringConfiguration 1234567891011121314package com.noahcode.config;import org.springframework.context.annotation.*;/** * 该类是一个配置类，它的作用和bean.xml是一样的 *///@Configuration@ComponentScan(basePackages = "com.noahcode")@Import(JdbcConfig.class)@PropertySource("classpath:jdbcConfig.properties")public class SpringConfiguration &#123;&#125; /src/main/java/com/noahcode/config/JdbcConfig 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.noahcode.config;import com.mchange.v2.c3p0.ComboPooledDataSource;import org.apache.commons.dbutils.QueryRunner;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Scope;import javax.sql.DataSource;import java.beans.PropertyVetoException;public class JdbcConfig &#123; @Value("$&#123;jdbc.driver&#125;") private String driver; @Value("$&#123;jdbc.url&#125;") private String url; @Value("$&#123;jdbc.username&#125;") private String username; @Value("$&#123;jdbc.password&#125;") private String password; /** * 用于创建一个QueryRunner对象 * * @param dataSource * @return */ @Bean(name = "runner") @Scope("prototype") public QueryRunner createQueryRunner(DataSource dataSource) &#123; return new QueryRunner(dataSource); &#125; /** * 创建数据源对象 * * @return */ @Bean(name = "dataSource") public DataSource createDataSource() &#123; ComboPooledDataSource ds = new ComboPooledDataSource(); try &#123; ds.setDriverClass(driver); ds.setJdbcUrl(url); ds.setUser(username); ds.setPassword(password); return ds; &#125; catch (PropertyVetoException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; src/main/java/com/noahcode/service/IAccountService 12345678910111213141516171819202122232425262728293031323334353637383940package com.noahcode.service;import com.noahcode.domain.Account;import java.util.List;/** * 账户的业务层接口 */public interface IAccountService &#123; /** * 查询所有 * @return */ List&lt;Account&gt; findAllAccount(); /** * 查询一个 * @return */ Account findAccountByID(Integer accountId); /** * 保存 * @param account */ void saveAccount(Account account); /** * 更新 * @param account */ void updateAccount(Account account); /** * 删除 * @param accountId */ void deleteAccount(Integer accountId);&#125; src/main/java/com/noahcode/service/impl/IAccountService 12345678910111213141516171819202122232425262728293031323334353637383940package com.noahcode.service.impl;import com.noahcode.dao.IAccountDao;import com.noahcode.domain.Account;import com.noahcode.service.IAccountService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;/** * 账户的业务层实现类 */@Service("accountService")public class AccountServiceImpl implements IAccountService &#123; @Autowired private IAccountDao accountDao; public List&lt;Account&gt; findAllAccount() &#123; return accountDao.findAllAccount(); &#125; public Account findAccountByID(Integer accountId) &#123; return accountDao.findAccountByID(accountId); &#125; public void saveAccount(Account account) &#123; accountDao.saveAccount(account); &#125; public void updateAccount(Account account) &#123; accountDao.updateAccount(account); &#125; public void deleteAccount(Integer accountId) &#123; accountDao.deleteAccount(accountId); &#125;&#125; src/main/java/com/noahcode/dao/IAccountDao 12345678910111213141516171819202122232425262728293031323334353637383940package com.noahcode.dao;import com.noahcode.domain.Account;import java.util.List;/** * 账户的持久层 */public interface IAccountDao&#123; /** * 查询所有 * @return */ List&lt;Account&gt; findAllAccount(); /** * 查询一个 * @return */ Account findAccountByID(Integer accountId); /** * 保存 * @param account */ void saveAccount(Account account); /** * 更新 * @param account */ void updateAccount(Account account); /** * 删除 * @param accountId */ void deleteAccount(Integer accountId);&#125; src/main/java/com/noahcode/dao/impl/AccountDao 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.noahcode.dao.impl;import com.noahcode.dao.IAccountDao;import com.noahcode.domain.Account;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Repository;import java.sql.SQLException;import java.util.List;/** * 账户的持久层实现类 */@Repository("accountDao")public class AccountDao implements IAccountDao &#123; @Autowired private QueryRunner runner; public List&lt;Account&gt; findAllAccount() &#123; try &#123; return runner.query("select * from account",new BeanListHandler&lt;Account&gt;(Account.class)); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; public Account findAccountByID(Integer accountId) &#123; try &#123; return runner.query("select * from account where id = ?",new BeanHandler&lt;Account&gt;(Account.class),accountId); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; public void saveAccount(Account account) &#123; try &#123; runner.update("insert into account(name,money)values(?,?)",account.getName(),account.getMoney()); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; public void updateAccount(Account account) &#123; try &#123; runner.update("update account set name=?,money=? where id=?",account.getName(),account.getMoney(),account.getId()); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; public void deleteAccount(Integer accountId) &#123; try &#123; runner.update("delete from account where id=?",accountId); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; /src/main/java/resources/jdbcConfig.properties 1234jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/eesyjdbc.username=rootjdbc.password=5945 /src/test/java/com/noahcode/test/AccountServiceTest 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.noahcode.test;import com.noahcode.config.SpringConfiguration;import com.noahcode.domain.Account;import com.noahcode.service.IAccountService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import javax.sound.midi.Soundbank;import java.util.List;/** * 使用Junit单元测试，测试我们的配置 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = SpringConfiguration.class)public class AccountServiceTest &#123; @Autowired private IAccountService as; @Test public void testFindAll() &#123; List&lt;Account&gt; accounts = as.findAllAccount(); for (Account account : accounts) &#123; System.out.println(account); &#125; &#125; @Test public void testFindOne() &#123; Account account=as.findAccountByID(1); System.out.println(account); &#125; @Test public void testSave() &#123; Account account=new Account(); account.setName("test"); account.setMoney(4); as.saveAccount(account); &#125; @Test public void testUpdate() &#123; Account account=as.findAccountByID(2); account.setName("Noah"); account.setMoney(10); as.updateAccount(account); &#125; @Test public void testDelete() &#123; as.deleteAccount(2); &#125;&#125; 总结现在主要是记笔记了，记录视频中的知识点，还有一些经典案例代码，方便以后回头学习]]></content>
      <categories>
        <category>Java</category>
        <category>Spring 全家桶</category>
        <category>Spring</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Java</tag>
        <tag>Spring 全家桶</tag>
        <tag>入门</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的Spring学习之旅一]]></title>
    <url>%2F2019%2F06%2F03%2F%E6%88%91%E7%9A%84Spring%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%B8%80%2F</url>
    <content type="text"><![CDATA[之前学了三章的 Spring Boot 课程，然后换了三波教材，一开始自信的我直接磕文档，败下阵来后在b站找了一个极客时间的教程，学到多条数据源配置的时候看代码着实有点懵，就换了一套尚硅谷的 Spinrg Boot 教程，但是吧一进去老师就说，Spirng Boot 有一个缺点就是上手简单，精通很难因为他是由 Spring 集合而成的，所以想要学好 Spring Boot 就要先学好 Spinrg，接着我就来写此篇文章了。 参考教程b站是个好地方，现在我要学啥的时候都是先在b站找找有没有相关的教学视频. Spring教程IDEA版-4天-2018黑马 简介简单介绍 Spring 是一个一站式轻量级开源框架 IOC(反转控制)和AOP(面向切面编程)为内核 提供了展现层 Spring MVC 和持久层 Spring JDBC 以及业务层事物管理等众多的企业级应用技术，还可以整合开元世界众多著名的第三方框架和类库 具体描述 轻量级：Spring 使非侵入性的-基于 Spring 开发地应用中的对象可以不依赖于 Spring 的 API 依赖注入：(DI—dependency injection、IOC) 面向切面编程(AOP–aspect oriented programming) 容器：Spring 是一个容器，因为他包含并且管理应用对象的生命周期 一站式：在 IOC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库(实际上 Spring 自身也提供了展现层的 SpringMVC 和 持久层的 Spring JDBC) 优势 方便解耦 简化开发 AOP 编程的支持 声明式事物的支持 方便程序的测试 方便集成各种优秀的框架 降低 JavaEE API 的使用难度 Java 源码是经典学习案例 Spring 的体系结构 方便解耦 简化开发代码1pom.xml 1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.noahcode&lt;/groupId&gt; &lt;artifactId&gt;day01_spring&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.13&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; Demo1.java 12345678910111213141516171819202122232425262728293031package com.noahcode.spring.jdbc;import javax.naming.Name;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;/** * 程序的解耦 */public class Demo1 &#123; public static void main(String[] args) throws Exception &#123; //1.注册驱动 DriverManager.registerDriver(new com.mysql.jdbc.Driver()); //2.获取连接 Connection conn=DriverManager.getConnection("jdbc:mysql://localhost:3306/eesy","root","5945"); //3.获取操作数据库的预处理对象 PreparedStatement pst=conn.prepareStatement("select * from account"); //4.执行SQL，得到结果集 ResultSet rs=pst.executeQuery(); //5.遍历结果集 while (rs.next())&#123; System.out.println(rs.getString("name")); &#125; //6.释放资源 rs.close(); pst.close(); conn.close(); &#125;&#125; 知识点1．耦合：程序见的依赖关系 包括： 类之间的依赖 方法间的依赖 ２．解耦： 降低程序间的依赖关系 ３．实际开发中： 应该做到：编译期不依赖，运行时才依赖 4.解耦的思路： 第一步：使用反射来创建对象，而避免使用 new 关键字 第二步：通过读取配置文件来获取要创建的对象全限定类名 从老师中的总结，我才知道为什么会有配置文件这个东西，此处感悟很深。 代码2因为此处的代码多为展示程序的依赖性，所以代码比较分散，就不粘贴代码了。 知识点1．Bean：在计算机英语中，有可重用组件的含义 2．JavaBean：用Java语言编写的可重用组件 javabean = 实体类 它不等于 javabean &gt; 实体类 3．如何创建我们的service和dao对象的 第一个：需要一个配置文件来配置我们的service和dao 配置文件的内容：唯一标识=全限定类名(key=value) 第二个：通过读取配置文件中的配置内容，反射创建对象 我的配置文件可以是 xml 也可以是 properties 知识点 ApplicationContext的三个常用实现类 ClassPathXmlApplicatonContext：他可以加载类路径下的配置文件，要求配置文件必须在类路径下，不在的话加载不了 FileSystemXmlApplicationContext:他可以加载磁盘任意路径下的配置文件(必须有访问权限) AnnotationConfigApplicationContext:他用于读取注解创建容器的 核心容器的两个接口引发出的问题： ApplicationContext: 单例对象适用(实际开发中较多使用此接口) 他在构建核心容器时，创建对象采取的策略是采用立即加载的方式，也就是说，只要一读取完配置文件马上就创建配置文件中配置的对象 代码： 123ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");IAccountService as = (IAccountService) ac.getBean("accountService");IAccountDao adao = (IAccountDao) ac.getBean("accountDao", IAccountDao.class); BeanFactory: 多例对象适用 他在构建核心容器时，创建对象采取的策略是采用延迟加载的方式，也就是说，什么时候根据id获取对象了，什么时候才真正的创建对象 代码： 123Resource resource = new ClassPathResource("bean.xml");BeanFactory factory = new XmlBeanFactory(resource);IAccountService as = (IAccountService) factory.getBean("accountService"); Spring对bean的管理细节 创建bean的三种方式 第一种：使用默认构造函数创建 在Spring的配置文件中使用bean标签，配以id和class属性之后，且没有其他属性和标签时，采用的就是默认构造函数创建bean对象，此时如果类中没有默认构造函数，则对象无法创建 1&lt;bean id="accountService" class="com.noahcode.service.impl.AccountServiceImpl"&gt;&lt;/bean&gt; 第二种：使用普通工厂中的方法创建对象(使用某个类中的方法创建对象，并存入Spirng容器中) 12&lt;bean id="instanceFactory" class="com.noahcode.factory.InstanceFactory"&gt;&lt;/bean&gt;&lt;bean id="accountService" factory-bean="instanceFactory" factory-method="getAccountService"&gt;&lt;/ bean&gt; 第三种：使用工厂中的静态方法创建对象(使用某个类中的静态方法创建对象，并存入Spring容器中) 1&lt;bean id="accountService" class="com.noahcode.factory.staticFactory" factory-method="getAccountService"&gt;&lt;/bean&gt; bean对象的作用范围调整 bean标签的scope属性： 作用：用于指定bean的作用范围 取值：(常用的就是单例的和多例的) singleton:单例的(默认值) 意义：在整个系统上下文环境中，仅有一个Bean实例。也就是说，在整个系统上下文环境中，你通过Spring IOC获取的都是同一个实例。 prototy:多例的 意义：意味着程序每次从IOC容器获取的Bean都是一个新的实例 request:作用于web应该用的请求范围 session:作用于web应该用的会话范围 global-session:用用语集群环境的会话范围(全局会话范围),当不是集群环境时，他就是session bean对象的生命周期 单例对象 出生：当容器创建时对象出生 活着：只要容器存在，对象一直活着 死亡：容器销毁，对象死亡 多例对象 出生：当我们使用对象时Spring框架为我们创建 活着：对象只要实在使用过程中一直活着 死亡：当对象长时间不用且没有别的对象引用时，由Java的垃圾回收机制回收 Spring的依赖注入 IOC的作用 降低程序间的耦合(依赖关系) 依赖关系的管理 以后都交给spring来维护 在当前类需要用到其他类的对象，由spring为我们提供，我们只需要在配置文件中说明 依赖关系的维护 就称之为依赖注入 依赖注入 能注入的数据：有三种 基本数据类型和String 其他bean类型(在配置文件中或者注解配置过的bean) 复杂类型/集合类型 注入的方式：有三种 使用构造函数提供 使用set方式提供 使用注解提供 注意：若是经常变化的数据，并不适合用于注入的方式 构造函数注入 使用的标签：constructor-arg 标签的出现位置：bean标签的内部 标签中的属性： type：用于指定要注入的数据的数据类型，该数据类型也是构造函数中某个或某些参数的类型 index：用于指定要注入的数据给构造函数中指定索引位置的参数赋值。索引的位置是从0开始 name：用于指定给构造函数中指定名称的参数赋值 (常用的) value：用于提供基本类型和String类型的数据 ref：用于指定其他的bean类型数据。他指的就是在spring的IOC核心容器中出现过的bean对象 优势 在获取bean对象时，诸如数据是必须的操作，否则对象无法创建。 弊端 改变了bean对象的实例化方式，使我们在创建对象时，如果用不到这些数据，也必须提供。 代码 123456&lt;bean id="accountService" class="com.noahcode.service.impl.AccountServiceImpl"&gt;&lt;constructor-arg name="name" value="test"&gt;&lt;/constructor-arg&gt;&lt;constructor-arg name="id" value="18"&gt;&lt;/constructor-arg&gt;&lt;constructor-arg name="birthday" ref="now"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;bean id="now" class="java.util.Date"&gt;&lt;/bean&gt; set方法注入 (更常用的方式) 使用标签：property 出现的位置：bean标签的内部 标签中的属性： name:用于指定注入时所调用的set方法名称 value:用于提供基本类型和String类型的数据 ref:用于指定其他的bean类型数据。他指的就是在spring的IOC核心容器中出现过的bean对象 优势： 创建对象时没有明确的的限制，可以直接使用默认构造函数 弊端： 如果有某个成员必须有值，则获取对象时有可能set方法没有执行 代码123456&lt;bean id="accountService" class="com.noahcode.service.impl.AccountServiceImpl"&gt;&lt;property name="name" value="test"&gt;&lt;/property&gt;&lt;property name="id" value="18"&gt;&lt;/property&gt;&lt;property name="birthday" ref="now"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id="now" class="java.util.Date"&gt;&lt;/bean&gt; 复杂类型的注入/集合类型的注入 我们分别测试了array，list，set，map和properties这五种复杂类型。 用于给List结构集合注入的标签： list array set 用于给Map结构集合注入的标签： map props总结：结构相同，标签可以互换12345678910111213141516171819202122232425262728293031323334&lt;bean id="accountService" class="com.noahcode.service.impl.AccountServiceImpl"&gt; &lt;property name="myString"&gt; &lt;array&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;value&gt;ccc&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name="myList"&gt; &lt;list&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;value&gt;ccc&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="mySet"&gt; &lt;set&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;value&gt;ccc&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name="myMap"&gt; &lt;map&gt; &lt;entry key="key1" value="value1"&gt;&lt;/entry&gt; &lt;entry key="key2" value="value2"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name="myProperties"&gt; &lt;props&gt; &lt;prop key="test"&gt;test&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 总结 首先视频中的两张图真的是点睛之笔，原本听得有些似懂非懂的，看了图之后脑子思路清晰了很多 知道了bean对象的创建，虽然不是很熟练，但已经理解它创建的整体步骤。 这两张图完美的诠释了解耦的原理，为什么叫反转控制，也让我知道了工厂的重要性，老师讲的真的挺好的，赞一个！]]></content>
      <categories>
        <category>Java</category>
        <category>Spring 全家桶</category>
        <category>Spring</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Java</tag>
        <tag>Spring 全家桶</tag>
        <tag>入门</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的SpringBoot学习之旅(二)]]></title>
    <url>%2F2019%2F06%2F01%2F%E6%88%91%E7%9A%84SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[这是我 Spring Boot学习的第二章，由于文档已经看不懂了，所以选择了从网上找视频来看，然后在b站上看到了极客时间的 Spring Boot 全家桶视频，所以这篇文章是以此视频为参考。 参考资料极客时间SpringBoot全家桶视频 简介极客时间的视频看的话其实也有点难度，他需要你有一定基础，有些东西我也看不懂，但是可以一点点去摸索，靠猜测它的意思吧，继续靠着这种方法学习，如果实在遇到不能搞懂的，就还是老老实实的回头学基础去了。 这篇文章学习的是它的第5节课内容–将项目与数据库进行连接获取相关信息。 创建项目视频中使用的是我上一篇文章中总结出的三种方法中的官网创建的方法，我是用的编辑器创建，其实都一样只要依赖选项没搞错就行。 读取连接数据库相关信息代码编辑在我们的/src/main/java/xxx/xxx.java中编辑我们的代码 1234567891011121314151617181920212223242526272829303132333435package com.noahcode.test.demo;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.CommandLineRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;@SpringBootApplication@Slf4jpublic class DemoApplication implements CommandLineRunner &#123; @Autowired private DataSource dataSource; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125; @Override public void run(String... args) throws Exception&#123; showConnection(); &#125; private void showConnection() throws SQLException&#123; log.info(dataSource.toString()); Connection conn=dataSource.getConnection(); log.info(conn.toString()); conn.close(); &#125;&#125; 代码分析注解这一次我们又看到了几个新的注解，我们在一个个去了解一下。 @Slf4j 实现日志输出 在类上添加@Slf4j注解，在方法中直接使用log @Autowired @Autowired表示被修饰的类需要注入对象,spring会扫描所有被@Autowired标注的类,然后根据 类型 在ioc容器中找到匹配的类注入。 Spring 会自动帮我们把 Bean 里面的对象的 setter/getter 给省略，它会自动帮我们完成 set/get 的操作，之后你需要用到的话可以直接使用。 @Override 这个注解就很熟悉–重构方法，就不做多讲了 代码 首先两个注解，@SpringBootApplication 不用过多解释标准注解，@Slf4j 用于实现日志输出，我们在方法中直接使用 log 方法。 将我们的主类引入一个借口–CommandLineRunner，我们按住 ctrl 键选择 CommandLineRunner 会发现这个接口中只有一个 run 方法，之后我们就需要重构它。 向我们的 Spring 中注入一个 dataSource 这个 DataSource 类型对象，然后我们的 @Autowired 注解就会帮我们完成自动装配的工作，来消除get/set的方法。 主方法就是运行我们的主类嘛 重写了我们接口–CommandLineRunner 的 run 方法，让它运行时调用我们写的 showConnection 的方法。 写了一个 showConnnection 的异常处理方法，里面使用了 log.info 来输出日志信息，先是输出了我们连接数据库的信息，然后连接输出连接数据库池的信息，最后关闭连接。 Spring Boot 做的配置 DataSourceAutoConfiguration 配置 DataSource DataSourceTransactionManagerAutoConfiguration 配置 DataSourceTransactionManager JdbcTemplateAutoConfiguration 配置 JdbcTemplate 当老师讲到这些完全是蒙的，没想到 Spring Boot 为我们做了这么多。 数据源相关配置属性通用 spring.datasource.url=jdbc:mysql://localhost/test spring.datasource.username=dbuser spring.datasource.password=dbpass spring.datasource.drive-class-name=com.mysql.jdbc.Driver(可选) 初始化内嵌数据库 spring.datasource.initialization-mode=embedded|always|never spring.datasource.schema与spring.datasource.data确定初始化SQL文件 spring.datasource.platform=hsqldb|h2|oracle|mysql|postgresql(与前者对应) 读取数据库内的数据编写代码首先在我们的/src/main/resources目录下，创建两个 sql 文件–schema.sql和data.sql schema.sql 1CREATE TABLE FOO(ID INT IDENTITY ,BAR VARCHAR(64)); data.sql 12INSERT INTO FOO(ID,BAR) VALUES(1,'aaa');INSERT INTO FOO(ID,BAR) VALUES(2,'bbb'); 再在我们的/src/main/java/xxx/xxx.java中编辑我们的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.noahcode.test.demo;import io.micrometer.core.instrument.MultiGauge;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.CommandLineRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.jdbc.core.JdbcTemplate;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;@SpringBootApplication@Slf4jpublic class DemoApplication implements CommandLineRunner &#123; @Autowired private DataSource dataSource; @Autowired private JdbcTemplate jdbcTemplate; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125; @Override public void run(String... args) throws Exception&#123; showConnection(); showData(); &#125; private void showConnection() throws SQLException&#123; log.info(dataSource.toString()); Connection conn=dataSource.getConnection(); log.info(conn.toString()); conn.close(); &#125; private void showData()&#123; jdbcTemplate.queryForList("select * from foo").forEach(row -&gt; log.info(row.toString())); &#125;&#125; 代码分析注解注解并没有出现新的，所以还是一样的 代码 又向我们的 Spring 中注入一个 jdbcTemplate 这个 JdbcTemplate 类型对象 在我们重构的 run 方法里又让他调用了一个 showData 的方法。 创建了一个 ShowData 的方法在里面使用了一段查询SQL语句，然后使用foreach 遍历所有数据内容将每一行数据使用日志输出。 总结学到现在总体感觉还行，现在的一些操作还是很容易就理解的，结合百度再扩展一点还是能接受的下来的，继续努力了。]]></content>
      <categories>
        <category>Java</category>
        <category>Spring 全家桶</category>
        <category>Spring Boot</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Java</tag>
        <tag>Spring 全家桶</tag>
        <tag>Spring Boot</tag>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的 Spring Boot 学习之旅(一)]]></title>
    <url>%2F2019%2F05%2F30%2F%E6%88%91%E7%9A%84SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%B8%80%2F</url>
    <content type="text"><![CDATA[这次终于确定了我学习的方向了，不再变了就是它了，之前一直犹豫到底该干什么，往哪个方向学习，心中一直想做的是游戏开发，但是从其他途径询问了两位在职程序员，他们都不推荐我做游戏开发，一位老师推荐我做前端就业市场大，还有以为推荐我做Java后端，最终我选择了做Java这条路。 参考文档：Break易站 ImportNew 配置环境 Java 1234λ java -versionjava version &quot;11.0.3&quot; 2019-04-16 LTSJava(TM) SE Runtime Environment 18.9 (build 11.0.3+12-LTS)Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.3+12-LTS, mixed mode) Maven 123456λ mvn -vApache Maven 3.6.1 (d66c9c0b3152b2e69ee9bac180bb8fcc8e6af555; 2019-04-05T03:00:29+08:00)Maven home: F:\JavaSpace\WorkSpaces\Maven\apache-maven-3.6.1Java version: 11.0.3, vendor: Oracle Corporation, runtime: F:\JavaSpace\JDK\jdk11Default locale: zh_CN, platform encoding: GBKOS name: &quot;windows 10&quot;, version: &quot;10.0&quot;, arch: &quot;amd64&quot;, family: &quot;windows&quot; 注：需要确保系统已安装了Java和Maven的有效版本 创建项目其中我总结了三种创建项目的方法，分别位自己创建，Spring Boot官网创建还有编辑器创建三种，下面分别介绍这三种方法如何去创建。 自己创建网站中使用的就是自己创建，虽然麻烦一点但是可以让小白的我们明白一个 Spring Boot 项目的文件结构。 Spring Boot 官网创建创建 Spring Boot 项目网址：start.spring.io 注：其中的 dependencies 依赖选项 记得要 add 添加 Web 即可。 创建完成后他就会下载一个压缩包，解压缩完后就是一个完整的 Spring Boot 项目了。 编辑器创建我使用的是 IDEA ，使用 eclipse 的朋友可以参考Spring boot入门：在Eclipse中搭建Spring boot 项目 然后就选择 Next 下一步，这个界面其实很熟悉就是我们上一种在 Spring Boot 官网创建项目是一样的，然后填写并选择所需要的选项然后继续选择 Next 选项 下面就是添加我们的依赖了，选择 Web 中的 Web 即可。 接下来就是我们项目的路径了，选择完后 Finish 选项后就创建好我们的 Spring Boot 项目了。 编写代码代码的编辑在 src/main/java/com.noahcode.demo/DemoApplication 文件编辑(此处以我的路径举例) 12345678910111213141516171819202122package com.noahcode.demo; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.EnableAutoConfiguration; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController;@RestController@EnableAutoConfigurationpublic class DemoApplication &#123; @RequestMapping("/") String home()&#123; return "Hello World!"; &#125; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; 代码分析注解对注解一点都不懂的我说实话一开始见到这个有点蒙，总感觉它像注释，对程序运行啥的应该不影响，之后去翻阅资料，才知道它的重要性，以下内容基本摘抄于原博客，并不是很理解的透彻，云里雾里的，以后多多使用来感受它的作用。 @SpringBootApplication 在文档中我们并没有看到这个注解，但是我们在IDEA中创建的项目中，使用了此注解，然后我们来了解一下。 他是个组合注解，包含一下三个配置@SpringBootConfiguration、@EnableAutoConfigration和@ComponentScan三个注解，接下来我们回依次分析 @SpringBootConfiguration 它继承自 @Configuration,标注当前类是配置类，会把当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到 Spring 的容器中，并且实例名就是方法名。 源码： 123456@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Configurationpublic @interface SpringBootConfiguration &#123;&#125; @ComponentScan 这个注解在 Spring 的注解中起到很重要的作用，他可以自定义 Spring扫描的包，默认回扫描标有@Controller、@Service、@Component以及@Repository注解的类，并且实例化到 SpringIOC 的容器中，其中它的源码中有个配置属性：basePackages，用来指定扫描的包，如果不知道，他会扫描配置了该注解的类的包所在的路径 源码： 12345@AliasFor( annotation = ComponentScan.class, attribute = "basePackages" ) String[] scanBasePackages() default &#123;&#125;; 在Spring Boot 中我们也可以将 scanBasePackages 属行指定包扫描的路径(若不指定默认扫描主程序类所在的包路径以及子包下的类) e.g. 1@SpringBootApplication(scanBasePackages = "com.seagetech.springbootdemo") @EnableAutoConfiguration 这个注解是 Spring Boot 完成自动配置的关键，此注解完成的是将所有符合自动配置条件的 bean 的定义加载到 Spring 的容器中。 源码： 12345678910111213@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(&#123;AutoConfigurationImportSelector.class&#125;)public @interface EnableAutoConfiguration &#123; String ENABLED_OVERRIDE_PROPERTY = "spring.boot.enableautoconfiguration"; Class&lt;?&gt;[] exclude() default &#123;&#125;; String[] excludeName() default &#123;&#125;;&#125; 可以看到它的源码又引用了很多注解，下面我们依次来分析它们。 @AutoConfigurationPackage 这个注解的功能就是自动配置包，获取主程序类所在的包路径，并将包路径下的所有组件注册到 SpringIOC 容器中。 @Import({AutoConfigurationImportSelector.class}) @Import 是 @EnableAutoConfiguration 的重要功能用于导入配置,使用的是 SpringFactoriesLoadFactoryNames 方法来扫描具有 META-INF/spirng.factories 文件的 jar 包。 home 方法添加了 @RequestMapping 注释告诉 Spring ，任何带有 / 路径的 HTTP 请求都应该映射到 home 方法，最后告诉 Spring 将结果字符串直接呈现给调用者。 总结没有一点基础说实话有点难理解，到现在都半知半解的，像注解啊什么的感觉还需要多练习之后才能懂得它的作用。]]></content>
      <categories>
        <category>Java</category>
        <category>Spring 全家桶</category>
        <category>Spring Boot</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Java</tag>
        <tag>Spring 全家桶</tag>
        <tag>Spring Boot</tag>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的Markdown编辑器]]></title>
    <url>%2F2019%2F05%2F11%2F%E6%88%91%E7%9A%84Markdown%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[这篇文章主要介绍的就是我使用的 Markdown 编辑器推荐，用的软件还是挺多的，但是主推还是--Atom。 经历我有很多东西都是看网上其他教程看到的才知道的，就像我使用Markdown语言来写文章，我当初就是看前端的教程然后看到老师使用的Markdown来写笔记感觉很神奇，然后才深入了解并且逐渐爱上了这款语言，省去了我们大部分的文章美化时间，并且我还有些强迫症，排版一定要有模有样的那种才行。 系统以前是使用过Mac系统，也使用过相关的Markdown编辑器软件来书写文章，我感觉最好用的就是MacDown这款软件，能提供实时上下滚动，右侧实时更新文章预览，感觉还是很棒的，但是用的不是很多，之后就是因为电脑存储太小128g固态，并且学校学习使用的都是window系统，很麻烦就放弃了我的Macbook Air，然后重新买了一台惠普光影精灵，电脑感觉还行，就是散热这个问题好像是笔记本通病了，风扇有些吵其他没什么，诶呀，好像越来越偏移主题了。 window使用的软件就相对与Mac多一点并且使用的时间也长，像什么别人推荐的印象笔记啊，MaHua，简书，MarkdownPad(付费软件，可以破解)，Atom，Visual Studio Code，到最近又发现一款Typed这款软件，其实有些还是可以的，但是我最终还是选择了Atom这款编辑器。 Atom他是一款文本编辑器软件，一开始知道这款软件是看一篇微信小程序的教程时看到老师使用这款软件来编写代码，我当时是因为他的主题深深的吸引住了，天哪，怎么可以这么好看！！！ 它的主题搭配之后也被我用来制作了很多东西，什么输入法皮肤，什么PPT的主题等等等。 插件为了方便我们编写Markdown语言，我安装了如下几个插件 Markdown系列： language-Markdown(代码增强) 一般的Markdown编辑器提供了代码着色等基本功能，language-markdown除了能给代码着色，还提供了快捷的代码片段生成等功能。 markdown-table-editor(表格创建编辑) 虽然我没写多少文章但是我用到表格的地方真的少，但感觉之后肯定会用到的，所以我还留着 markdown-preview-enhanced(markdown预览) 网上都推荐的是 markdown-preview-plus + markdown-scroll-sync 这两个插件配合使用，但是我的markdown-scroll-sync这个插件老是报错，不懂为啥，在怪我英文不好，更加不想搞了，最后看到这个插件拯救了我，Markdown预览以及实时滚动一个插件直接搞定，我还是推荐一下这款插件。 Atom美化插件 file-icon(图标美化) 推荐这款主要就是使用的人多，其他的我也没试过，不管了，随大流了，啥时候看见什么好看的再说吧。 activate-power-mode(装逼利器) 打字时候会有爆炸特效，乖乖大爱好吧！以前在使用XCode编辑器的时候才知道有这么个插件，当时爽的不行，然后XCode更新到8了之后不可以安装插件了，就渐渐淡忘了，然而Atom又重新让我使用到了！ 好了，我的Markdown编辑器就推荐到这里了，大家一起加油呀！！！]]></content>
      <categories>
        <category>Markdown</category>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>Atom</tag>
        <tag>Markdown</tag>
        <tag>编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016届蓝桥杯 Java C组 省赛试题及答案]]></title>
    <url>%2F2019%2F03%2F12%2F2016%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF-Java-C%E7%BB%84-%E7%9C%81%E8%B5%9B%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%2F</url>
    <content type="text"><![CDATA[在之前其实写了一篇2015年决赛的文章，但是发现每一条我感觉都要去翻阅别人的代码，这样子的效率太低了，所以赶紧开始做2016届的省赛题 结果填空有奖猜谜题目小明很喜欢猜谜语。最近，他被邀请参加了X星球的猜谜活动。 每位选手开始的时候都被发给777个电子币。规则是：猜对了，手里的电子币数目翻倍，猜错了，扣除555个电子币, 扣完为止。 小明一共猜了15条谜语。战果为：vxvxvxvxvxvxvvx其中v表示猜对了，x表示猜错了。 请你计算一下，小明最后手里的电子币数目是多少。 请填写表示最后电子币数目的数字。注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。 思路这毕竟第一条嘛没啥难度，直接计算器算都可以算出来，所以就不过多的说啥了。 答案58497 代码12345678910111213141516public class Main &#123; public static void main(String[] args) &#123; int x = 777; int[] b = &#123; 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0 &#125;; for (int i = 0; i &lt; b.length; i++) &#123; if (b[i] == 1) &#123; x *= 2; &#125; else &#123; x -= 555; &#125; &#125; System.out.println(x); &#125;&#125; 煤球数目题目有一堆煤球，堆成三角棱锥形。具体：第一层放1个，第二层3个（排列成三角形），第三层6个（排列成三角形），第四层10个（排列成三角形），….如果一共有100层，共有多少个煤球？ 请填表示煤球总数目的数字。注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。 思路对，这是一条找规律的题目，你们可能已经做出来了，但是愚蠢的我居然还看了答案才知道，天呐，这么简单的规律我都没想到真的很蠢， 总想着是什么 2^n-1 之类相对比较复杂的答案，然后看了答案后都怀疑自己是不是个傻子。。。 答案171700 代码123456789101112public class Main &#123; public static void main(String[] args) &#123; int num = 0, sum = 0; for (int i = 1; i &lt;= 100; i++) &#123; num += i; sum += num; &#125; System.out.println(sum); &#125;&#125; 平方怪圈题目如果把一个正整数的每一位都平方后再求和，得到一个新的正整数。对新产生的正整数再做同样的处理。 如此一来，你会发现，不管开始取的是什么数字，最终如果不是落入1，就是落入同一个循环圈。 请写出这个循环圈中最大的那个数字。 请填写该最大数字。注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。 思路这道题我一开始做的时候就直接找了几个数手算算出了最终结果，比赛的时候还是聪明点，只要能得出答案就行，但现在毕竟是在练习嘛我还是选择写了代码运行出最终结果，代码有点乱并不是最优代码，但我感觉稍微看看应该看得懂的. 答案145 代码123456789101112131415161718192021222324252627282930313233343536public class Main &#123; static int sum; public static void main(String[] args) &#123; int time = 0, max = 0; loop: for (int i = 1; i &lt; 100; i++) &#123; getSum(i); if (time == 1000) &#123; System.out.println(max); break; &#125; else &#123; while (time &lt; 1000) &#123; if (sum == 1) &#123; time = 0; continue loop; &#125; getSum(sum); if (max &lt; sum) &#123; max = sum; &#125; time++; &#125; &#125; &#125; &#125; public static void getSum(int n) &#123; String str = String.valueOf(n); char[] charArrays = str.toCharArray(); sum = 0; for (int i = 0; i &lt; charArrays.length; i++) &#123; sum += Math.pow((int) charArrays[i] - 48, 2); &#125; &#125;&#125; 代码填空骰子游戏题目我们来玩一个游戏。同时掷出3个普通骰子（6个面上的数字分别是1~6）。如果其中一个骰子上的数字等于另外两个的和，你就赢了。 下面的程序计算出你能获胜的精确概率（以既约分数表示） 123456789101112131415161718192021public class Main&#123; public static int gcd(int a, int b) &#123; if(b==0) return a; return gcd(b,a%b); &#125; public static void main(String[] args) &#123; int n = 0; for(int i=0; i&lt;6; i++) for(int j=0; j&lt;6; j++) for(int k=0; k&lt;6; k++)&#123; if(________________________________) n++; //填空位置 &#125; int m = gcd(n,6*6*6); System.out.println(n/m + "/" + 6*6*6/m); &#125;&#125; 仔细阅读代码，填写划线部分缺少的内容。 注意：不要填写任何已有内容或说明性文字。 思路这道题不难简单理解一下就行了，但是这题目坏的就是它的 for 循环的值设置的不好，它的取值只有0-5，但是骰子我们都知道是1-6所以我们判断大小时候每个值都要加上1，所以做这类题目的时候要认真审题和理解它的代码。 答案i + 1 == j + k + 2 || j + 1 == i + k + 2 || k + 1 == i + j + 2 代码12345678910111213141516171819202122public class Main &#123; public static int gcd(int a, int b) &#123; if (b == 0) return a; return gcd(b, a % b); &#125; public static void main(String[] args) &#123; int n = 0; for (int i = 0; i &lt; 6; i++) for (int j = 0; j &lt; 6; j++) for (int k = 0; k &lt; 6; k++) &#123; if (i + 1 == j + k + 2 || j + 1 == i + k + 2 || k + 1 == i + j + 2) n++; // 填空位置 &#125; int m = gcd(n, 6 * 6 * 6); System.out.println(n / m + "/" + 6 * 6 * 6 / m); &#125;&#125; 分小组题目9名运动员参加比赛，需要分3组进行预赛。有哪些分组的方案呢？ 我们标记运动员为 A,B,C,… I下面的程序列出了所有的分组方法。 该程序的正常输出为： 1234567891011121314151617181920212223242526272829303132ABC DEF GHIABC DEG FHIABC DEH FGIABC DEI FGHABC DFG EHIABC DFH EGIABC DFI EGHABC DGH EFIABC DGI EFHABC DHI EFGABC EFG DHIABC EFH DGIABC EFI DGHABC EGH DFIABC EGI DFHABC EHI DFGABC FGH DEIABC FGI DEHABC FHI DEGABC GHI DEFABD CEF GHIABD CEG FHIABD CEH FGIABD CEI FGHABD CFG EHIABD CFH EGIABD CFI EGHABD CGH EFIABD CGI EFHABD CHI EFGABD EFG CHI..... (以下省略，总共560行)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class A&#123; public static String remain(int[] a) &#123; String s = ""; for(int i=0; i&lt;a.length; i++)&#123; if(a[i] == 0) s += (char)(i+'A'); &#125; return s; &#125; public static void f(String s, int[] a) &#123; for(int i=0; i&lt;a.length; i++)&#123; if(a[i]==1) continue; a[i] = 1; for(int j=i+1; j&lt;a.length; j++)&#123; if(a[j]==1) continue; a[j]=1; for(int k=j+1; k&lt;a.length; k++)&#123; if(a[k]==1) continue; a[k]=1; System.out.println(__________________________________); //填空位置 a[k]=0; &#125; a[j]=0; &#125; a[i] = 0; &#125; &#125; public static void main(String[] args) &#123; int[] a = new int[9]; a[0] = 1; for(int b=1; b&lt;a.length; b++)&#123; a[b] = 1; for(int c=b+1; c&lt;a.length; c++)&#123; a[c] = 1; String s = "A" + (char)(b+'A') + (char)(c+'A'); f(s,a); a[c] = 0; &#125; a[b] = 0; &#125; &#125;&#125; 仔细阅读代码，填写划线部分缺少的内容。 注意：不要填写任何已有内容或说明性文字。 思路这道题怎么说呢，我可能做完了才基本知道了啥意思，我的答案完全靠猜出来的，首先有一个方法 remain 没有使用所以这个输出中肯定要使用到，还有一个 s 没有输出，最后肯定也要输出，看了一下答案刚好是第一列和第三列，还剩下中间这一列就可以完成了，看了一下这个 f 方法，刚好有三个 for 循环看样子可能表示的就是中间的数，然后我们模仿一下 mian 方法中的 (char)(b+’A’) 试了一下，居然真的完成了，我可真是个机灵鬼！！！ 答案s+” “+(char)(i+’A’)+(char)(j+’A’)+(char)(k+’A’)+” “+remain(a) 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class 分小组 &#123; public static String remain(int[] a) &#123; String s = ""; for(int i=0; i&lt;a.length; i++)&#123; if(a[i] == 0) s += (char)(i+'A'); &#125; return s; &#125; public static void f(String s, int[] a) &#123; for(int i=0; i&lt;a.length; i++)&#123; if(a[i]==1) continue; a[i] = 1; for(int j=i+1; j&lt;a.length; j++)&#123; if(a[j]==1) continue; a[j]=1; for(int k=j+1; k&lt;a.length; k++)&#123; if(a[k]==1) continue; a[k]=1; System.out.println(s+" "+(char)(i+'A')+(char)(j+'A')+(char)(k+'A')+" "+remain(a)); //填空位置 a[k]=0; &#125; a[j]=0; &#125; a[i] = 0; &#125; &#125; public static void main(String[] args) &#123; int[] a = new int[9]; a[0] = 1; for(int b=1; b&lt;a.length; b++)&#123; a[b] = 1; for(int c=b+1; c&lt;a.length; c++)&#123; a[c] = 1; String s = "A" + (char)(b+'A') + (char)(c+'A'); f(s,a); a[c] = 0; &#125; a[b] = 0; &#125; &#125;&#125; 结果填空凑算式题目12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 B DEFA + --- + ------- = 10 C GHI``` （如果显示有问题，可以参见【图1.jpg】）这个算式中A~I代表1~9的数字，不同的字母代表不同的数字。比如：6+8/3+952/714 就是一种解法，5+3/1+972/486 是另一种解法。这个算式一共有多少种解法？注意：你提交应该是个整数，不要填写任何多余的内容或说明性文字。![诶呀,图片加载出了点问题!](https://noahcodemonkey.top/images/img/2016届蓝桥杯JavaC组省赛试题及答案/图1.jpg)#### 思路一开始我看到这题目想到的方法就是全排列算法，但是不知道之后为啥运行不出结果，我从网上找了一下答案也没啥错误啊，然后最后我还是用了暴力破解才做出了结果，全排列的方法之后再写吧，我先挂上我的暴力破解，但是我感觉如果在比赛中用的话会爆内存的，我电脑配置还算可以了，还运行了有一会儿，风扇都转的飞起。。。#### 代码暴力破解法```Javapublic class Main &#123; public static void main(String[] args) &#123; int count=0; double A,B,C; for(int a=1;a&lt;10;a++) &#123; A=a; for(int b=1;b&lt;10;b++) &#123; for(int c=1;c&lt;10;c++) &#123; B=b*1.00/c; for(int d=1;d&lt;10;d++) &#123; for(int e=1;e&lt;10;e++) &#123; for(int f=1;f&lt;10;f++) &#123; for(int g=1;g&lt;10;g++) &#123; for(int h=1;h&lt;10;h++) &#123; for(int i=1;i&lt;10;i++) &#123; C=(d*100+e*10+f)*1.00/(g*100+h*10+i); if(PD(a,b,c,d,e,f,g,h,i)&amp;&amp;A+B+C==10)&#123; count++; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; System.out.println(count); &#125; public static boolean PD(int a,int b,int c,int d,int e,int f,int g,int h,int i) &#123; String str=a+" "+b+" "+c+" "+d+" "+e+" "+f+" "+g+" "+h+" "+i; if(str.contains("1")&amp;&amp;str.contains("2")&amp;&amp;str.contains("3")&amp;&amp;str.contains("4")&amp;&amp;str.contains("5")&amp;&amp;str.contains("6")&amp;&amp;str.contains("7")&amp;&amp;str.contains("8")&amp;&amp;str.contains("9")) &#123; return true; &#125; return false; &#125;&#125; 全排列解法 123456789101112131415161718192021222324252627282930313233343536public class 凑算式 &#123; static int count = 0; public static void main(String[] args) &#123; int a[] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;; f(a, 0); System.out.println(count); &#125; public static void f(int[] a, int begin) &#123; double q, w, e; if (begin == a.length - 1) &#123; q = a[0]; w = a[1] * 1.00 / a[2]; e = (a[3] * 100 + a[4] * 10 + a[5]) * 1.00 / (a[6] * 100 + a[7] * 10 + a[8]); if (q + w + e == 10) &#123; count++; &#125; &#125; for (int i = begin; i &lt; a.length; i++) &#123; &#123; int tmp = a[i]; a[i] = a[begin]; a[begin] = tmp; &#125; f(a, begin + 1); &#123; int tmp = a[i]; a[i] = a[begin]; a[begin] = tmp; &#125; &#125; &#125;&#125; 冰雹数题目任意给定一个正整数N，如果是偶数，执行： N / 2如果是奇数，执行： N * 3 + 1 生成的新的数字再执行同样的动作，循环往复。 通过观察发现，这个数字会一会儿上升到很高，一会儿又降落下来。就这样起起落落的，但最终必会落到“1”这有点像小冰雹粒子在冰雹云中翻滚增长的样子。 比如N=99,28,14,7,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,1可以看到，N=9的时候，这个“小冰雹”最高冲到了52这个高度。 输入格式：一个正整数N（N&lt;1000000）输出格式：一个正整数，表示 不大于N的数字 ，经过冰雹数变换过程中，最高冲到了多少。 例如，输入：10程序应该输出：52 再例如，输入：100程序应该输出：9232 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 1000ms 请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。 所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。注意：不要使用package语句。不要使用jdk1.7及以上版本的特性。注意：主类的名字必须是：Main，否则按无效代码处理。 思路看到我划的重点了嘛？对，就是加粗的那块地方，我真的是想暴揍这道题的作者，难得能自己独立写出一道递归题，想要找找自己的存在感，居然跟我玩文字游戏，一开始我的代码运行9没问题，但是运行到10答案就不一样了，我就纳闷了，这么简单的题目我不可能错啊，自己做了至少3次的手动推算，怎么也是16这个结果啊，然后就去找资料查找原因，看到他们的main函数就懵了，为啥n要卸载循环里啊？？？完全没道理啊，他不是只要输入一个值然后递归吗？然后又看了一篇文章，也是这样？但这篇文章将我标注的地方也加粗了并用红色标明了，可看了几眼还是没看出头绪，最后的最后终于搞懂了。。。(我承认我语文不好) 代码1234567891011121314151617181920212223242526272829303132public class Main &#123; public static void main(String[] args) &#123; Scanner s1 = new Scanner(System.in); int n = s1.nextInt(); int max = 0; for (int i = 1; i &lt;= n; i++) &#123; int tmp = BBS(i, max); if (tmp &gt; max) &#123; max = tmp; &#125; &#125; System.out.println(max); &#125; public static int BBS(int n, int max) &#123; if (n == 1) &#123; return max; &#125; else &#123; if (n % 2 == 0) &#123; n /= 2; &#125; else &#123; n = n * 3 + 1; &#125; if (n &gt; max) &#123; max = n; &#125; return BBS(n, max); &#125; &#125;&#125; 四平方和题目四平方和定理，又称为拉格朗日定理：每个正整数都可以表示为至多4个正整数的平方和。如果把0包括进去，就正好可以表示为4个数的平方和。 比如：5 = 0^2 + 0^2 + 1^2 + 2^27 = 1^2 + 1^2 + 1^2 + 2^2（^符号表示乘方的意思） 对于一个给定的正整数，可能存在多种平方和的表示法。要求你对4个数排序：0 &lt;= a &lt;= b &lt;= c &lt;= d并对所有的可能表示法按 a,b,c,d 为联合主键升序排列，最后输出第一个表示法 程序输入为一个正整数N (N&lt;5000000)要求输出4个非负整数，按从小到大排序，中间用空格分开 例如，输入： 5 则程序应该输出： 0 0 1 2 再例如，输入： 12 则程序应该输出： 0 2 2 2 再例如，输入： 773535 则程序应该输出： 1 1 267 838 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 3000ms 请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。 所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。注意：不要使用package语句。不要使用jdk1.7及以上版本的特性。注意：主类的名字必须是：Main，否则按无效代码处理。 思路哇，看到这道题都哭了，为什么感觉从2018年以前的题都相对于比较简单啊，这居然是第9条的题目，完全可以暴力破解嘛。但是之后的代码应该需要优化一下循环取值的范围，太大的话应该会超内存。 代码1234567891011121314151617181920public class Main &#123; public static void main(String[] args) &#123; Scanner s1 = new Scanner(System.in); int n = s1.nextInt(); for (int i = 0; i &lt; Math.sqrt(n); i++) &#123; for (int j = i; j &lt; Math.sqrt(n); j++) &#123; for (int k = j; k &lt; Math.sqrt(n); k++) &#123; for (int m = k; m &lt; Math.sqrt(n); m++) &#123; if (i * i + j * j + k * k + m * m == n) &#123; System.out.println(i + " " + j + " " + k + " " + m); return; &#125; &#125; &#125; &#125; &#125; &#125;&#125; 密码脱落题目X星球的考古学家发现了一批古代留下来的密码。这些密码是由A、B、C、D 四种植物的种子串成的序列。仔细分析发现，这些密码串当初应该是前后对称的（也就是我们说的镜像串）。由于年代久远，其中许多种子脱落了，因而可能会失去镜像的特征。 你的任务是：给定一个现在看到的密码串，计算一下从当初的状态，它要至少脱落多少个种子，才可能会变成现在的样子。 输入一行，表示现在看到的密码串（长度不大于1000）要求输出一个正整数，表示至少脱落了多少个种子。 例如，输入：ABCBA则程序应该输出：0 再例如，输入：ABDCDCBABC则程序应该输出：3 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 3000ms 请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。 所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。注意：不要使用package语句。不要使用jdk1.7及以上版本的特性。注意：主类的名字必须是：Main，否则按无效代码处理。 思路思路就是找到中间值然后依次往两边作比较，相同则继续往两边找，如果不同就分两种情况，一个是将右边的值添加在左边另一种相反，然后在判断。。。这只是个想法，也不知道对不对，第十条都暂时不研究了 代码1还在脑海中加载...]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>省赛</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>2016届</tag>
        <tag>蓝桥杯</tag>
        <tag>Java</tag>
        <tag>C组</tag>
        <tag>省赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2015届蓝桥杯 Java C组 省赛试题及答案]]></title>
    <url>%2F2019%2F03%2F05%2F2015%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF-Java-C%E7%BB%84-%E7%9C%81%E8%B5%9B%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%2F</url>
    <content type="text"><![CDATA[因为今年3月份要参加这一届的蓝桥杯比赛，为此刷真题并写下一些文章留些记录，不管最后的成绩如何，我努力了！加油！！！ 结果填空1隔行变色题目 Excel 表的格子很多，为了避免把某行的数据和相邻行混淆，可以采用隔行变色的样式。 小明设计的样式为：第1行蓝色，第2行白色，第3行蓝色，第4行白色，…. 现在小明想知道，从第21行到第50行一共包含了多少个蓝色的行。 请你直接提交这个整数，千万不要填写任何多余的内容。 思路 由题可知，颜色的变化是由行号的奇偶性来判断的，所以我们只需要在给定的范围内循环一下，在循环中加入一个 if判断是奇是偶，因为题目只需要输出蓝色行的个数，我们就可以判断它是否为奇数，若是奇数则次数加1即可. 答案 15 代码 123456789101112131415161718 import java.util.Scanner;public class _01 &#123; public static void main(String[] args) &#123; Scanner s1 = new Scanner(System.in); int start = s1.nextInt(); int end = s1.nextInt(); int count = 0; for (int i = start; i &lt;= end; i++) &#123; if (i % 2 != 0) &#123; count++; &#125; &#125; System.out.println(count); &#125;&#125; 立方尾不变题目有些数字的立方的末尾正好是该数字本身。比如：1,4,5,6,9,24,25,…. 请你计算一下，在10000以内的数字中（指该数字，并非它立方后的数值），符合这个特征的正整数一共有多少个。 请提交该整数，不要填写任何多余的内容。 思路一开始我想的很简单，就是单纯的拿10000的 for 循环中判断 i == Math.pow(i, 3) % 10 ,之后看见题目中举得例子不止我用上面代码测试出的5这个结果,发现他的结尾不一定是就是最后一位啊,应该 i 是几位它的结尾就该留几位,为了解决这个问题,我想到的是用 String 的 length 方法,详情请看代码. 答案36 代码123456789101112131415161718public class Main &#123; public static void main(String[] args) &#123; int count = 0; for (int i = 1; i &lt;= 10000; i++) &#123; String str = "" + i; int yu = 1; for (int j = 0; j &lt; str.length(); j++) &#123; yu *= 10; &#125; if (i == Math.pow(i, 3) % yu) &#123; count++; &#125; &#125; System.out.println(count); &#125;&#125; 无穷分数题目无穷的分数，有时会趋向于固定的数字。 请计算【图1.jpg】所示的无穷分数，要求四舍五入，精确到小数点后5位，小数位不足的补0。 请填写该浮点数，不能填写任何多余的内容。 思路首先,很明显一看到这个题目我就想到了用递归做,但是细看了题目以后,发现有点看不懂了,他为什么没有规定出口值?那他不还要一直循环下去嘛?那这结果怎么求嘛?无奈之下,从网上查找了答案,才清楚这题目的意思,原来它的结果会随着运算的次数越多,会越来越精确一个值,我们只需要把那个大约值求出来即可. 答案0.58198 代码1234567891011121314public class Main &#123; public static void main(String[] args) &#123; System.out.printf("%.5f", FS(1)); &#125; public static double FS(double n) &#123; if (n &gt;= 100) &#123; return n; &#125; else &#123; return n / (n + FS(n + 1)); &#125; &#125;&#125; 代码填空循环节长度题目两个整数做除法，有时会产生循环小数，其循环部分称为：循环节。比如，11/13=6=&gt;0.846153846153….. 其循环节为[846153] 共有6位。下面的方法，可以求出循环节的长度。 请仔细阅读代码，并填写划线部分缺少的代码。 1234567891011121314public static int f(int n, int m)&#123; n = n % m; Vector v = new Vector(); for(;;) &#123; v.add(n); n *= 10; n = n % m; if(n==0) return 0; if(v.indexOf(n)&gt;=0) _________________________________ ; //填空 &#125;&#125; 注意，只能填写缺少的部分，不要重复抄写已有代码。不要填写任何多余的文字。 思路这道题,一上来其实已经想到了如何解决,但是自己太蠢,唉,服了!!!一上来我就把代码放到eclipse中运行,把需要填空的地方我改成了让它输出 v.indexOf ,果不其然答案就在其中,看到结果一直在循环0-5,这不就是答案了嘛,然后我就使劲想啊想啊,想不懂怎么把他们搞出来,总想着把5能取出来最后加1啥的乱七八糟的东西,无奈毫无进展,只好从网上寻找答案,当看到答案时心都凉了一半,这么简单为啥就是想不到… 答案return v.size(); 代码12345678910111213141516171819202122232425import java.util.Vector;public class Main &#123; public static void main(String[] args) &#123; System.out.println(f(11, 13)); &#125; public static int f(int n, int m) &#123; n = n % m; Vector v = new Vector(); for (;;) &#123; v.add(n); n *= 10; n = n % m; if (n == 0) return 0; if (v.indexOf(n) &gt;= 0) &#123; return v.size(); &#125; &#125; &#125;&#125; 格子中输出题目stringInGrid方法会在一个指定大小的格子中打印指定的字符串。要求字符串在水平、垂直两个方向上都居中。如果字符串太长，就截断。如果不能恰好居中，可以稍稍偏左或者偏上一点。 下面的程序实现这个逻辑，请填写划线部分缺少的代码。 123456789101112131415161718192021222324252627282930public static void stringInGrid(int width, int height, String s)&#123; if(s.length()&gt;width-2) s = s.substring(0,width-2); System.out.print("+"); for(int i=0;i&lt;width-2;i++) System.out.print("-"); System.out.println("+"); for(int k=1; k&lt;(height-1)/2;k++)&#123; System.out.print("|"); for(int i=0;i&lt;width-2;i++) System.out.print(" "); System.out.println("|"); &#125; System.out.print("|"); String ff = _______________________________________________________; //填空 System.out.print(String.format(ff,"",s,"")); System.out.println("|"); for(int k=(height-1)/2+1; k&lt;height-1; k++)&#123; System.out.print("|"); for(int i=0;i&lt;width-2;i++) System.out.print(" "); System.out.println("|"); &#125; System.out.print("+"); for(int i=0;i&lt;width-2;i++) System.out.print("-"); System.out.println("+");&#125; 对于题目中数据，应该输出： 123456+------------------+| || abcd1234 || || |+------------------+ （如果出现对齐问题，参看【图1.jpg】） 思路一开始遇到这题一脸蒙,首先时不知道String.format的作用,查了API和网上资料搜索之后才知道，这个就是C语言的输出格式嘛，但是当我试了一下填入 “%s%s%s” 虽然值是在格子中输出出来了，但是并没有居中，这可咋整？然后直接在网上查找原题，但看到的都是C语言版的不过也看出了一下名堂，在 %s 中间居然可以添加一个整数来控制它前面的空格数，然后我就将其更改为 “%” + (width - s.length()) / 2 + “s%s%” + (width - s.length()) / 2 + “s”; ，谁知运行后还是显示不对，原来是我忘了两边还有一个 | 也要算进去。 答案“%” + (width - s.length() - 2) / 2 + “s%s%” + (width - s.length() - 2) / 2 + “s”; 代码123456789101112131415161718192021222324252627282930313233343536373839404142public class Main &#123; public static void main(String[] args) &#123; stringInGrid(20, 6, "abcd1234"); &#125; public static void stringInGrid(int width, int height, String s) &#123; if (s.length() &gt; width - 2) s = s.substring(0, width - 2); System.out.print("+"); for (int i = 0; i &lt; width - 2; i++) System.out.print("-"); System.out.println("+"); for (int k = 1; k &lt; (height - 1) / 2; k++) &#123; System.out.print("|"); for (int i = 0; i &lt; width - 2; i++) System.out.print(" "); System.out.println("|"); &#125; System.out.print("|"); String ff = "%" + (width - s.length() - 2) / 2 + "s%s%" + (width - s.length() - 2) / 2 + "s";// 填空 System.out.print(String.format(ff, "", s, "")); System.out.println("|"); for (int k = (height - 1) / 2 + 1; k &lt; height - 1; k++) &#123; System.out.print("|"); for (int i = 0; i &lt; width - 2; i++) System.out.print(" "); System.out.println("|"); &#125; System.out.print("+"); for (int i = 0; i &lt; width - 2; i++) System.out.print("-"); System.out.println("+"); &#125;&#125; 结果填空题2奇妙的数字题目小明发现了一个奇妙的数字。它的平方和立方正好把0~9的10个数字每个用且只用了一次。你能猜出这个数字是多少吗？ 请填写该数字，不要填写任何多余的内容。 思路看到这题目想到的就是 for 循环遍历数字，然后计算它的平方和立方再去判断它们刚好使用0-9这10个数各一次。一开始我计算他们的平方和立方时选择的是使用Math.pow()这个方法，但是它返回值是double类型的，之后求它的长度时会有影响，所以我还是改成了最传统的相乘，多说无益，直接上代码吧。 答案69 代码123456789101112131415161718192021222324public class Main &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 100; i++) &#123; int pf = i * i; int lf = i * i * i; String str = pf + " " + lf; if (PD(str) &amp;&amp; (String.valueOf(pf).length() + String.valueOf(lf).length() == 10)) &#123; System.out.println(i); break; &#125; &#125; &#125; public static boolean PD(String str) &#123; if (str.contains("1") &amp;&amp; str.contains("2") &amp;&amp; str.contains("3") &amp;&amp; str.contains("4") &amp;&amp; str.contains("5") &amp;&amp; str.contains("6") &amp;&amp; str.contains("7") &amp;&amp; str.contains("8") &amp;&amp; str.contains("9") &amp;&amp; str.contains("0")) &#123; return true; &#125; return false; &#125;&#125; 加法变乘法题目我们都知道：1+2+3+ … + 49 = 1225现在要求你把其中两个不相邻的加号变成乘号，使得结果为2015 比如：1+2+3+…+10*11+12+…+27*28+29+…+49 = 2015就是符合要求的答案。 请你寻找另外一个可能的答案，并把位置靠前的那个乘号左边的数字提交（对于示例，就是提交10）。 注意：需要你提交的是一个整数，不要填写任何多余的内容。 思路一开始我想到的方法就是建立一个数组，然后靠两个不相邻的两组相乘数减去这两组数的相加之后的和，让其结果等于2015-1225即可，但之后我一直遇到的问题就是结果不一样，我还在哪儿找了半天原因，但感觉自己的想法真的没有错误啊，为啥答案就是不一样？然后找网上的答案，才发现完全可以直接两个 for 循环嵌套即可，完全没必要在搞个数组画蛇添足了，看了一下他们的代码，和我的想法一样啊为啥我的就是错的？整了半天终于找出了原因，因为我数组是从0开始赋值的，最后答案要加1就正确了。。。。 代码1234567891011121314151617public class Main &#123; public static void main(String[] args) &#123; end: for (int i = 1; i &lt;= 47; i++) &#123; for (int j = 3; j &lt; 49; j++) &#123; if (i * (i + 1) + j * (j + 1) - i - (i + 1) - j - (j + 1) == 2015 - 1225) &#123; if (i == 10) &#123; continue; &#125; System.out.println(i); break end; &#125; &#125; &#125; &#125;&#125; 移动距离题目X星球居民小区的楼房全是一样的，并且按矩阵样式排列。其楼房的编号为1,2,3…当排满一行时，从下一行相邻的楼往反方向排号。比如：当小区排号宽度为6时，开始情形如下： 1 2 3 4 5 612 11 10 9 8 713 14 15 ….. 我们的问题是：已知了两个楼号m和n，需要求出它们之间的最短移动距离（不能斜线方向移动） 输入为3个整数w m n，空格分开，都在1到10000范围内要求输出一个整数，表示m n 两楼间最短移动距离。 例如：用户输入：6 8 2则，程序应该输出：4 再例如：用户输入：4 7 20则，程序应该输出：5 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 1000ms 请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。 所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。注意：不要使用package语句。不要使用jdk1.7及以上版本的特性。注意：主类的名字必须是：Main，否则按无效代码处理。 思路这道题乍一看很简单，但是开始做之后就开始各种问题出现，我感觉不做过多解释了吧，这题需要去理解我就直接呈上我的代码了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142public class Main &#123; public static void main(String[] args) &#123; Scanner s1 = new Scanner(System.in); int w = s1.nextInt(); int m = s1.nextInt(); int n = s1.nextInt(); int cha = 0, newNum = 0, sum = 0; int max1 = initMax(w, Math.min(m, n)); int min1 = max1 - 5; int max2 = initMax(w, Math.max(m, n)); int min2 = max2 - 5; if (isJI(w, max1)) &#123; cha = Math.min(m, n) - min1; &#125; else &#123; cha = max1 - Math.min(m, n); &#125; if (isJI(w, max2)) &#123; newNum = min2 + cha; &#125; else &#123; newNum = max2 - cha; &#125; System.out.println(max1 + " " + max2); System.out.println(Math.abs(Math.max(m, n) - newNum) + " " + (max2 / max1 - 1)); sum = Math.abs(Math.max(m, n) - newNum) + max2 / max1 - 1; System.out.println(sum); &#125; public static int initMax(int w, int n) &#123; int tmp = w; while (w &lt; n) &#123; w += tmp; &#125; return w; &#125; public static boolean isJI(int w, int n) &#123; if (n / w % 2 != 0) &#123; return true; &#125; return false; &#125;&#125; 打印大X题目小明希望用星号拼凑，打印出一个大X，他要求能够控制笔画的宽度和整个字的高度。为了便于比对空格，所有的空白位置都以句点符来代替。 要求输入两个整数m n，表示笔的宽度，X的高度。用空格分开(0&lt;m&lt;n, 3&lt;n&lt;1000, 保证n是奇数)要求输出一个大X 例如，用户输入：3 9程序应该输出： 123456789***.....***.***...***...***.***.....*****.......***.......*****.....***.***...***...***.***.....*** （如有对齐问题，参看【图1.jpg】） 再例如，用户输入：4 21程序应该输出 123456789101112131415161718192021****................****.****..............****...****............****.....****..........****.......****........****.........****......****...........****....****.............****..****...............********.................******...................****...................******.................********...............****..****.............****....****...........****......****.........****........****.......****..........****.....****............****...****..............****.****................**** （如有对齐问题，参看【图2.jpg】） 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 1000ms 请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。 所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。注意：不要使用package语句。不要使用jdk1.7及以上版本的特性。注意：主类的名字必须是：Main，否则按无效代码处理。 思路这种打印类型的题目都得靠找规律去完成，像本题因为他是一个上下对称图形，所以我们可以分开为上下两半完成即可，比赛中我们只需将所有精力放在上半部分，当我们把上半部分完成后就可以，下半部分只需要复制一下再改几个值即可。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Main &#123; public static void main(String[] args) &#123; Scanner s1 = new Scanner(System.in); // 笔的宽度 int m = s1.nextInt(); // x的高度 int n = s1.nextInt(); // 列数 int y = m + n - 1; // 上半段 for (int a = 0; a &lt; (n + 1) / 2; a++) &#123; int count = (y - 2 * m) - a * 2; for (int i = 0; i &lt; a; i++) &#123; System.out.print("."); &#125; for (int i = 0; i &lt; m; i++) &#123; System.out.print("*"); &#125; for (int i = count - 1; i &gt;= 0; i--) &#123; System.out.print("."); &#125; if (count &gt;= 0) &#123; for (int i = 0; i &lt; y - (2 * a + m) - count; i++) &#123; System.out.print("*"); &#125; &#125; else &#123; for (int i = 0; i &lt; y - (2 * a + m); i++) &#123; System.out.print("*"); &#125; &#125; for (int i = 0; i &lt; a; i++) &#123; System.out.print("."); &#125; System.out.println(); &#125; // 下半段 for (int a = (n + 1) / 2 - 1; a &gt;= 0; a--) &#123; int count = (y - 2 * m) - a * 2; for (int i = 0; i &lt; a; i++) &#123; System.out.print("."); &#125; for (int i = 0; i &lt; m; i++) &#123; System.out.print("*"); &#125; for (int i = count - 1; i &gt;= 0; i--) &#123; System.out.print("."); &#125; if (count &gt;= 0) &#123; for (int i = 0; i &lt; y - (2 * a + m) - count; i++) &#123; System.out.print("*"); &#125; &#125; else &#123; for (int i = 0; i &lt; y - (2 * a + m); i++) &#123; System.out.print("*"); &#125; &#125; for (int i = 0; i &lt; a; i++) &#123; System.out.print("."); &#125; System.out.println(); &#125; &#125;&#125; 垒骰子题目赌圣atm晚年迷恋上了垒骰子，就是把骰子一个垒在另一个上边，不能歪歪扭扭，要垒成方柱体。经过长期观察，atm 发现了稳定骰子的奥秘：有些数字的面贴着会互相排斥！我们先来规范一下骰子：1 的对面是 4，2 的对面是 5，3 的对面是 6。假设有 m 组互斥现象，每组中的那两个数字的面紧贴在一起，骰子就不能稳定的垒起来。 atm想计算一下有多少种不同的可能的垒骰子方式。两种垒骰子方式相同，当且仅当这两种方式中对应高度的骰子的对应数字的朝向都相同。由于方案数可能过多，请输出模 10^9 + 7 的结果。 不要小看了 atm 的骰子数量哦～ 「输入格式」第一行两个整数 n mn表示骰子数目接下来 m 行，每行两个整数 a b ，表示 a 和 b 不能紧贴在一起。 「输出格式」一行一个数，表示答案模 10^9 + 7 的结果。 「样例输入」2 11 2 「样例输出」544 「数据范围」对于 30% 的数据：n &lt;= 5对于 60% 的数据：n &lt;= 100对于 100% 的数据：0 &lt; n &lt;= 10^9, m &lt;= 36 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 2000ms 请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。 所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。注意：不要使用package语句。不要使用jdk1.7及以上版本的特性。注意：主类的名字必须是：Main，否则按无效代码处理。 思路动态规划题。。。。不会不会不会，递归都有时候绕不出来的我，对动态规划充满了阴影，但没办法呀，去网上找资料死磕了。 代码这题我选择先放放再刷其他题了，但在此处提供自认为写得很详细的一位博主的文章，有时间可以去看看研究。 JacobKong_Dev的简书]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>省赛</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>Java</tag>
        <tag>C组</tag>
        <tag>省赛</tag>
        <tag>2015届</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity 官方案例进阶--Roll a ball]]></title>
    <url>%2F2018%2F11%2F15%2FUnity%E5%AE%98%E6%96%B9%E6%A1%88%E4%BE%8B%E8%BF%9B%E9%98%B6-Roll-a-ball%2F</url>
    <content type="text"><![CDATA[经过上一次的学习，我又想改进一下这款 Roll a ball 游戏，首先这款游戏只有胜利没有失败，所以我想定义一个条件来控制它的输赢，因此我想到了如下的方案： 使我们的玩家控制 Player 在规定时间内达到一定的分数就胜利，反之则失败 任务目标这里只是大概的目标内容，还有一些细节会在后面完成的时候体现出来。 完成 PickUp 的随机刷新出现，每隔3秒刷新一个 做一个倒计时器用于显示游戏剩余时间 控制分数和时间，若玩家在规定时间内达到分数则显示 You Win！字样，Player 禁止移动；若失败，则小球爆炸并显示 Game Over！ 字样。 环境搭建主体还是 Roll a ball 的内容，其中有一些小改动，我们在此完成一下。 删除场景中的所有 PickUp因为我们要完成的是随机刷新 PickUp 物体，所以我们不需要在场景中添加 PickUp 物体，到时候会用到一个新的知识来完成我们的随机显示 PickUp 物体的操作。 添加倒计时文本因为我们需要让玩家知道游戏的剩余时间，所以我们需要添加一个用来显示时间的文本，位置我选择在了中间顶部的位置，其他设置随意。 细节修改因为最终我们显示的文本不再是只有胜利，所以将我们之前创建的 WinText 改名为 ResultText。 遗漏补充在官方的案例中，PickUp 是有一个黄色的材质，而我在之前做的项目中忘记添加了，所以我现在添加了一个黄色材质球给我们的 PickUp。 以上就是我们的环境搭建相关的操作，下面就要开始我们的脚本编写，来实现游戏的运行了。 游戏运行修改以及准备我将 PlayerController 中除了将 Player 运动的脚本其余的都删除了。 脚本文件名：PlayerController 代码如下： using System.Collections; using System.Collections.Generic; using UnityEngine; public class PlayerController : MonoBehaviour { public float speed; private float moveHorizontal; private float moveVertical; private Vector3 movement; private void FixedUpdate() { moveHorizontal = Input.GetAxis(&quot;Horizontal&quot;); moveVertical = Input.GetAxis(&quot;Vertical&quot;); movement = new Vector3(moveHorizontal, 0.0f, moveVertical); GetComponent&lt;Rigidbody&gt;().AddForce(movement * speed * Time.deltaTime); } }我将剩下的代码贴在上方了，有不清楚的或者项目删除了的可以直接复制过去。 创建 GameController 脚本还是在我们的 Player 物体上添加脚本取名为 GameController ，我定义它用来控制整个游戏的运行脚本，其实我们游戏的改变主要就是体现在此脚本的编写，所以当我们完成此脚本的编写也就意味着我们游戏的完成，废话不多说了下面我们就来完成它。 删除补回因为我们将原来 PlayerController 脚本中除了控制小球运动的代码都删除了，所以需要先补充一下 Planyer 与 PickUp 的碰撞以及分数控制的相关代码，此时只是补回后面还会有更改。 脚本文件名：GameController 代码如下： 123456789101112131415161718192021222324252627282930313233343536using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class GameController : MonoBehaviour &#123; public Text countText; private int count; private void Awake() &#123; count = 0; &#125; private void Start() &#123; SetCount(); &#125; private void OnTriggerEnter(Collider other) &#123; if (other.gameObject.tag == "PickUp") &#123; Destroy(other.gameObject); count++; SetCount(); &#125; &#125; void SetCount() &#123; countText.text = "Count:" + count; &#125;&#125; 目标一：刷新 PickUp 物体在此我们要完成的是让我们的 PickUp 物体在地面上的随机位置每3秒刷新一个。 这其中我们会用到几个新的知识，有需要的话最好还是去网上找找资料了解一下或者翻阅官网的API。 Clone 克隆物体 Randam 随机类 脚本文件名：GameController 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class GameController : MonoBehaviour &#123; public Text countText; //用于添加 PickUp 物体，之后克隆要用 public GameObject pickUp; private int count; //定义一个三维向量的值用于存储克隆物体的位置 private Vector3 newPickUpPt; //定义一个需要等待克隆物体的时间，根据目标应该赋值为3 private float fireRate; //定义一个下一次克隆物体的时间 private float nextFire; private void Awake() &#123; count = 0; //给 fireRate 赋值，控制克隆物体的间隔时间 fireRate = 3f; &#125; private void Start() &#123; SetCount(); &#125; private void Update() &#123; //判断游戏时间是否大于我们需要的它克隆的时间 if (Time.time &gt; nextFire) &#123; //计算下一次克隆时的时间 nextFire = Time.time + fireRate; //给我们的 PickUp 随机一个位置 newPickUpPt = new Vector3(Random.Range(-8, 8), 1f, Random.Range(-8, 8)); //这就是克隆的操作脚本了 //Instantiate(需要克隆的物体，克隆物体的 Pothion 值，克隆物体的 Rotation值) //此处我们要克隆的物体是 PickUp，他的位置就是我们之前随机存储的那个位置，Quaternion.identity 的意思是与原物体的 Rotation 值保持不变 Instantiate(pickUp, newPickUpPt, Quaternion.identity); &#125; &#125; private void OnTriggerEnter(Collider other) &#123; if (other.gameObject.tag == "PickUp") &#123; Destroy(other.gameObject); count++; SetCount(); &#125; &#125; void SetCount() &#123; countText.text = "Count:" + count; &#125;&#125; 脚本我们现在就写完了，保存一下脚本，然后来到我们的 Unity 编辑器中，给我们 Player 物体中的 GameController 脚本中的 Player 物体添加一下，然后运行就可以看到 PickUp 开始有规律的创建了。 控制倒计时器做倒计时器又需要用到一个新的知识–协程，这个知识还是很重要的，最好先去翻阅些资料了解一下它。 脚本文件名：GameController 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class GameController : MonoBehaviour &#123; public Text countText; //用于添加时间 Text 物体 public Text timeText; //用于添加 PickUp 物体，之后克隆要用 public GameObject pickUp; private int count; //定义一个三维向量的值用于存储克隆物体的位置 private Vector3 newPickUpPt; //定义一个需要等待克隆物体的时间，根据目标应该赋值为3 private float fireRate; //定义一个下一次克隆物体的时间 private float nextFire; private float time; private void Awake() &#123; count = 0; //给 fireRate 赋值，控制克隆物体的间隔时间 fireRate = 3f; time = 8; &#125; private void Start() &#123; SetCount(); //开始我们的协程 StartCoroutine(Timer()); &#125; private IEnumerator Timer() &#123; //定义一个循环，条件为要time&gt;0 while (time &gt; 0) &#123; //间隔1秒继续执行一下代码 yield return new WaitForSeconds(1); //time自减1 time--; //更新我们的时间文本 SetTime(); &#125; //结束我们的协程 StopCoroutine(Timer()); &#125; private void Update() &#123; //判断游戏时间是否大于我们需要的它克隆的时间 if (Time.time &gt; nextFire) &#123; //计算下一次克隆时的时间 nextFire = Time.time + fireRate; //给我们的 PickUp 随机一个位置 newPickUpPt = new Vector3(Random.Range(-8, 8), 1f, Random.Range(-8, 8)); //这就是克隆的操作脚本了 //Instantiate(需要克隆的物体，克隆物体的 Pothion 值，克隆物体的 Rotation值) //此处我们要克隆的物体是 PickUp，他的位置就是我们之前随机存储的那个位置，Quaternion.identity 的意思是与原物体的 Rotation 值保持不变 Instantiate(pickUp, newPickUpPt, Quaternion.identity); &#125; &#125; private void OnTriggerEnter(Collider other) &#123; if (other.gameObject.tag == "PickUp") &#123; Destroy(other.gameObject); count++; SetCount(); &#125; &#125; void SetCount() &#123; countText.text = "Count:" + count; &#125; void SetTime() &#123; timeText.text = time.ToString(); &#125;&#125; 控制结果方法挺多的，可以自己想想怎么去完成。 脚本文件名：GameController 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class GameController : MonoBehaviour &#123; public Text countText; //用于添加时间 Text 物体 public Text timeText; public Text resultText; //用于添加 PickUp 物体，之后克隆要用 public GameObject pickUp; private int count; //定义一个三维向量的值用于存储克隆物体的位置 private Vector3 newPickUpPt; //定义一个需要等待克隆物体的时间，根据目标应该赋值为3 private float fireRate; //定义一个下一次克隆物体的时间 private float nextFire; private float time; private void Awake() &#123; count = 0; //给 fireRate 赋值，控制克隆物体的间隔时间 fireRate = 3f; time = 8; &#125; private void Start() &#123; SetCount(); //开始我们的协程 StartCoroutine(Timer()); &#125; private IEnumerator Timer() &#123; //定义一个循环，条件为要time&gt;0 while (time &gt; 0) &#123; //间隔1秒继续执行一下代码 yield return new WaitForSeconds(1); //time自减1 time--; //更新我们的时间文本 SetTime(); //调用我们创建的控制结果函数 if (time &lt;= 0 &amp;&amp; count &lt; 2) &#123; resultText.text = "Game Over!"; &#125; else if (count &gt;= 2) &#123; resultText.text = "You Win!"; &#125; &#125; //结束我们的协程 StopCoroutine(Timer()); &#125; private void Update() &#123; //判断游戏时间是否大于我们需要的它克隆的时间 if (Time.time &gt; nextFire &amp;&amp; time &gt; 0) &#123; //计算下一次克隆时的时间 nextFire = Time.time + fireRate; //给我们的 PickUp 随机一个位置 newPickUpPt = new Vector3(Random.Range(-8, 8), 1f, Random.Range(-8, 8)); //这就是克隆的操作脚本了 //Instantiate(需要克隆的物体，克隆物体的 Pothion 值，克隆物体的 Rotation值) //此处我们要克隆的物体是 PickUp，他的位置就是我们之前随机存储的那个位置，Quaternion.identity 的意思是与原物体的 Rotation 值保持不变 Instantiate(pickUp, newPickUpPt, Quaternion.identity); &#125; &#125; private void OnTriggerEnter(Collider other) &#123; if (other.gameObject.tag == "PickUp") &#123; Destroy(other.gameObject); count++; SetCount(); &#125; &#125; void SetCount() &#123; countText.text = "Count:" + count; &#125; void SetTime() &#123; timeText.text = time.ToString(); &#125;&#125; 游戏的完善这是我们此游戏的最后部分，用于完善一些游戏中缺乏的地方，也添加了一些比较有意思的东西，来使游戏更加具有趣味性。 完善物体的克隆创建当游戏结束时，我们的克隆还在不停操作，这是我们不愿意看到的，所以接下来我们来完善它。 其实完善很简单，只需在我们克隆创建操作的 if 判断中添加条件就可以了。 脚本文件名：GameController 代码如下： 123456789101112131415private void Update() &#123; //判断游戏时间是否大于我们需要的它克隆的时间 if (Time.time &gt; nextFire &amp;&amp; time &gt; 0) &#123; //计算下一次克隆时的时间 nextFire = Time.time + fireRate; //给我们的 PickUp 随机一个位置 newPickUpPt = new Vector3(Random.Range(-8, 8), 1f, Random.Range(-8, 8)); //这就是克隆的操作脚本了 //Instantiate(需要克隆的物体，克隆物体的 Pothion 值，克隆物体的 Rotation值) //此处我们要克隆的物体是 PickUp，他的位置就是我们之前随机存储的那个位置，Quaternion.identity 的意思是与原物体的 Rotation 值保持不变 Instantiate(pickUp, newPickUpPt, Quaternion.identity); &#125; &#125; 完善倒计时器当我们游戏胜利后会发现我们的倒计时器依旧还在运行，所以这是有问题的，因此接下来我们就来完善它。 来到我们打代码，会发现我们的游戏胜利放在了倒计时器中的循环中，因此只要当我们胜利之后添加一个 个 Break 语句跳出循环就可以完成我们的倒计时停止的操作了。 脚本文件名：GmaeController 代买如下： 12345678910111213141516171819202122232425private IEnumerator Timer() &#123; //定义一个循环，条件为要time&gt;0 while (time &gt; 0) &#123; //间隔1秒继续执行一下代码 yield return new WaitForSeconds(1); //time自减1 time--; //更新我们的时间文本 SetTime(); //调用我们创建的控制结果函数 if (time &lt;= 0 &amp;&amp; count &lt; 2) &#123; resultText.text = "Game Over!"; &#125; else if (count &gt;= 2) &#123; resultText.text = "You Win!"; break; &#125; &#125; //结束我们的协程 StopCoroutine(Timer()); &#125; 写完代码后运行，然后完成我们的两个小球的条件后，会发现我们的倒计时停止了，耶！完成啦！但是我们又会惊喜的发现刚完成的游戏结束后停止创建物体的任务并没有完善，我们只考虑到了游戏失败时停止创建，若当游戏胜利结束时并没有考虑到，所以我们又要回过头来重新完善我们之前的任务。 补：完善物体的克隆创建要完善其实也很简单，只需要在我们创建的条件中再添加一个 Count 要小于我们的目标值就可以了。 脚本文件名： GameController 代码如下： 123456789101112131415private void Update() &#123; //判断游戏时间是否大于我们需要的它克隆的时间 if (Time.time &gt; nextFire &amp;&amp; time &gt; 0 &amp;&amp; count &lt; 2) &#123; //计算下一次克隆时的时间 nextFire = Time.time + fireRate; //给我们的 PickUp 随机一个位置 newPickUpPt = new Vector3(Random.Range(-8, 8), 1f, Random.Range(-8, 8)); //这就是克隆的操作脚本了 //Instantiate(需要克隆的物体，克隆物体的 Pothion 值，克隆物体的 Rotation值) //此处我们要克隆的物体是 PickUp，他的位置就是我们之前随机存储的那个位置，Quaternion.identity 的意思是与原物体的 Rotation 值保持不变 Instantiate(pickUp, newPickUpPt, Quaternion.identity); &#125; &#125; 趣味添加：游戏失败小球爆炸效果爆炸效果是从网上找的，在此感谢TPMer博主提供，爆炸效果需要用到的素材请到他的CSDN博客最底处下载。 TPMerd的CSDN博客 素材下载完成后记住他的下载位置当我们导入时需要用到，再打开我们的 Unity 编辑器在菜单栏中的 Assets 中找到 Import Package 再选择 Custom Package 选项来添加我们的素材，找到我们之前下载的素材包打开，在 Import Unity Package 界面中，我们勾去第一个 000.unity 场景文件后选择右下角的 Import 选项添加我们的素材。 然后编辑我们的脚本文件来完成我们的小球爆炸效果。 脚本文件名：GameController 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class GameController : MonoBehaviour &#123; public Text countText; //用于添加时间 Text 物体 public Text timeText; public Text resultText; //用于添加 PickUp 物体，之后克隆要用 public GameObject pickUp; //用于添加我们的爆炸物体 public GameObject Bang; private int count; //定义一个三维向量的值用于存储克隆物体的位置 private Vector3 newPickUpPt; //定义一个需要等待克隆物体的时间，根据目标应该赋值为3 private float fireRate; //定义一个下一次克隆物体的时间 private float nextFire; private float time; private void Awake() &#123; count = 0; //给 fireRate 赋值，控制克隆物体的间隔时间 fireRate = 3f; time = 8; &#125; private void Start() &#123; SetCount(); //开始我们的协程 StartCoroutine(Timer()); &#125; private IEnumerator Timer() &#123; //定义一个循环，条件为要time&gt;0 while (time &gt; 0) &#123; //间隔1秒继续执行一下代码 yield return new WaitForSeconds(1); //time自减1 time--; //更新我们的时间文本 SetTime(); //调用我们创建的控制结果函数 if (time &lt;= 0 &amp;&amp; count &lt; 2) &#123; resultText.text = "Game Over!"; //将 Player 物体销毁 Destroy(this.gameObject); //克隆我们的爆炸物体来代替我们的 Player 物体 Instantiate(Bang, this.transform.position, this.transform.rotation); &#125; else if (count &gt;= 2) &#123; resultText.text = "You Win!"; break; &#125; &#125; //结束我们的协程 StopCoroutine(Timer()); &#125; private void Update() &#123; //判断游戏时间是否大于我们需要的它克隆的时间 if (Time.time &gt; nextFire &amp;&amp; time &gt; 0 &amp;&amp; count &lt; 2) &#123; //计算下一次克隆时的时间 nextFire = Time.time + fireRate; //给我们的 PickUp 随机一个位置 newPickUpPt = new Vector3(Random.Range(-8, 8), 1f, Random.Range(-8, 8)); //这就是克隆的操作脚本了 //Instantiate(需要克隆的物体，克隆物体的 Pothion 值，克隆物体的 Rotation值) //此处我们要克隆的物体是 PickUp，他的位置就是我们之前随机存储的那个位置，Quaternion.identity 的意思是与原物体的 Rotation 值保持不变 Instantiate(pickUp, newPickUpPt, Quaternion.identity); &#125; &#125; private void OnTriggerEnter(Collider other) &#123; if (other.gameObject.tag == "PickUp") &#123; Destroy(other.gameObject); count++; SetCount(); &#125; &#125; void SetCount() &#123; countText.text = "Count:" + count; &#125; void SetTime() &#123; timeText.text = time.ToString(); &#125;&#125; 当我们将脚本写完保存后，打开 Unity 编辑器在我们的 Player 物体中 GameController 脚本下方的 Bang 处添加我们 Prefabs 文件下的爆炸文件后运行，当我们游戏结束时会发现我们的 Player 物体爆炸了，但是我们下方会有红色文字报错。 它的意思大体为 物体已经被销毁了，但是游戏依旧还在使用它 ，然后在找到下面的提示可以看到问题出现在了我们的 CameraController 文件中的第18行，我们顺着找过去看到的是我们用来使我们的相机位置为 Player 位置加上一个固定值的代码，找到了病因我们就去解决了。 脚本文件名：CameraController 代码如下： 1234567891011121314151617181920212223using System.Collections;using System.Collections.Generic;using UnityEngine;public class CameraController : MonoBehaviour &#123; public GameObject player; private Vector3 offset; private void Awake() &#123; offset = transform.position - player.transform.position; &#125; private void Update() &#123; if (null != player) &#123; transform.position = player.transform.position + offset; &#125; &#125;&#125; 解决方法很简单就是将我们的相机位置代码放在一个 if 判断语句中就行了，判断的条件就是我们的 Player 物体存在就行了。 总结以上就是这篇文章中的所有内容了，因为本人还是新手所以在很多内容上理解可能很不准确或者错误的，希望各位朋友能像我提出，我一定会悉心学习并改正的，我也会努力让自己与目标更加靠近的！！！ 欢迎大家收藏我的博客，我会努力更新更多的作品的，给自己加个油！]]></content>
      <categories>
        <category>教程</category>
        <category>Unity</category>
        <category>官方案例进阶</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>官方案例</tag>
        <tag>Roll a ball</tag>
        <tag>进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity官方案例--Roll a ball]]></title>
    <url>%2F2018%2F11%2F15%2FUnity%E5%AE%98%E6%96%B9%E6%A1%88%E4%BE%8B-Roll-a-ball%2F</url>
    <content type="text"><![CDATA[现在的我还是一名 Unity3d 游戏开发初学者，所以现在都在围绕 Unity3d 的官方案例来做练习，为此写下一些文章作为笔记，文章中难免会有一些疏漏，有些不当之处还望指正。 项目简介首先玩家可以控制一个小球，去吃那些悬浮在平面上的小方块，全部吃玩就游戏结束了，是一个很简单的小游戏。 创建工程首先我们创建一个空的工程 环境搭建创建地面在 Hierarchy 界面中右键选择 3D Object 中的 Plane 创建一个地面，其中将他 Inspector 界面中的 Scale(X:2,Y:1,Z:2)使地面扩大一下，这里需要让大家养成一个好的习惯就是物体的需要命名并且要有意义，所以我将我们的 Plan物体名改为 Ground。 给地面添加材质但由于这地面太白了，再加上默认的灯光效果很亮表现得很刺眼，所以我给地面添加了一个黑色的材质，这里有需要大家养成一个文件分类的好习惯，所以我在我们的 Assets 文件夹中新建了一个 Materials 文件夹用来存放我们需要用到的材质文件，选中 Materials 文件夹后右键选择 Create 选项中选择 Material 就可以创建一个材质文件了，我将它改名为 Ground，其中在他的 Inspector 界面中将 Main Maps 中的 Albedo 的颜色调整为黑色，最后只需将这个材质文件拖到我们场景中的地面上即可。 添加墙在 Hierarchy 界面中右键选择 3D Object 中的 Cube 来创建四周的墙，其中在它们的 Inspector 界面中都设置 Scale(X:21,Y:1,Z:1)，它们的位置分别设置为 Wall[Positon(X:0,Y:0,Z:10)], Wall1[Positon(X:0,Y:0,Z:-10)], Wall2[Position(X:10,Y:0,Z:0),Rotation(X:0,Y:90,Z:0)], Wall3[Position(X:-10,Y:0,Z:0),Rotation(X:0,Y:90,Z:0)] 这里又有一点需要大家养成的习惯就是若有相同的物体应该创建一个空的物体将他们都存放在你里面，所以我在 Hierarchy 中创建了一个空的物体改名为 Walls 将这四个墙存放在其中。 设置摄像机选择我们场景中的 Main Camera 设置它的 Position(X:0,Y:10,Z:-10),Rotation(X:45,Y:0,Z:0)即可。 添加 Player在 Hierarchy 界面中右键选择 3D Object 中选择 Sphere 将它改名为 Player，设置它的 Position(X:0,Y:0.5,Z:0) 添加 Pick Up在 Hierarchy 界面中右键选择 3D Object 中选择 Cube 将他改名为 Pickup ，其中几个比较关键的设置是 Position 的y的值最好要大于1因为过低 他会卡在地面里，Rotation(X:45,Y:45,Z:45)，还有一个特别关键的就是将 Box Collider 中的 Is Trigger 勾上，它的作用是做触发器，简单来说就是就是当两个物体发生碰撞不产生碰撞效果，但会触发碰撞事件(如果还不能理解，自己在 Unity 中实验一下)，然后就是多创建几个 Pick Up 位置你们随便放，不过这里也有一个方法方便我们创建多个相同的物体并且还可以同步之后需要更改的设置，那就是创建 Prefab。我们在 Assets 文件夹中创建一个 Prefabs 文件夹，将我们创建的 Pickup物体拖至此文件夹，当我们看到 Pickup 物体的名称变蓝后，这就意味着我们的 prefab 创建完成，当我们需要创建 Pickup 物体时，现在只需将 prefab 中的 Pickup 拖至我们的场景中即可创建，然后就是创建一个空的物体改名为 Pickups 用来存放我们创建的 Pickup 。 在 Inspector 界面中找到 Tag 选项后单机再选择选项中最下方的 Add Tag… 后会来到我们的 Tags &amp; Layers 界面，在下方会看见一个 + 标志后单机在输入框中输入 PickUp 后选择 Sa7e 后即可添加标签 添加 UI在 Hierarchy 界面中右键选择 UI 后再选择 Text 选项就可以添加我们的 UI 了，我们将创建出来的 Text 文件改名为 CountText，我们可以在 Inspector 界面中的 Text(Script) 中调整文字内容、字体、字体大小、颜色等多种属性，我们必须要做的是将文本默认的内容给删掉就行了，其他的设置看自己喜好了，但我们要将它至于界面的左上角该如何操作呢？我们可以在 Rect Transform 中看到一个田字格，我们单机一下它就会出现很多位置选项，但是并没有我们所需要的左上角，这时候我们只需要一直按住键盘上的 Alt 键就会发现上面的位置选项发生了变化，之后就可以很明显的看到左上角的选项然后我们选择它就可以了，然后在 Canvas 文件夹下在创建一个 Text 改名为 WinText 用来存储我们的胜利文本的，也要将文本内容删去，位置居中默认就行了，其他设置自定义。 游戏运行从这儿起就要开始我们的脚本编写了，现在 Unity3D 主流脚本编辑语言是 C#，不过像我现在用的 Unity 3D 2018.2的版本脚本语言只剩下了 C#，所以推荐大家写脚本还是用 C# 来编写，学过的朋友理解起来就很方便了，没学过的朋友可以从网上找找相关教学视频了解一下，不过有一点编程经验的其实理解起来还是很简单的，我会在下面脚本中写下相应注释的，方便一些初学者理解的。 Unity官方有一个脚本文档，在遇到什么不懂得问题或者需要完成什么操作脚本忘了怎么写时可以进行查阅。 Unity官方脚本文档 Player 的移动选择我们的 Player 物体文件，在 Inspector 的下方点击 Add Component 在其中的输入框中输入 Rigidbody 回车确定选择，即可给我们的 Player物体添加刚体组件，刚体组件的用处就是给物体添加物理属性的，其中我们将 Angular Drag 的值改为0，意思是取消小球的摩擦力。 还是点击 Add Component 在输入框中输入 PlayerController 选择 New script 再点击下方的 Create and Add 即可给我们的 Player 挂载脚本了，然后我在我们的 Assets 文件夹中创建一个 Scripts 文件夹用来存储我们游戏中的所有用到的脚本文件，将我们刚刚创建的脚本文件拖进此文件夹。 双击我们的脚本文件，就打开了我们默认的脚本编辑器来编辑我们的脚本，我使用的是 visual studio 2017。 下面就开始编辑我们的脚本，来完成小球 Player 的移动。 脚本文件名：PlayerController 代码如下： 12345678910111213141516171819202122232425using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerController : MonoBehaviour &#123;//public 公共的，会使此变量显示在 unity 编辑器中方便我们调节数值//此处定义一个 speed 变量是为了控制 Player 的运动速度public float speed;public void FixedUpdate()&#123; //获取横向要使 Player 位移的量 float moveHorizontal = Input.GetAxis("Horizontal"); //获取纵向要使 Player 位移的量 float moveVertical = Input.GetAxis("Vertical"); //定义一个新的三维向量，来确定 Player 的运行方向 Vector3 movement = new Vector3(moveHorizontal, 0.0f, moveVertical); //给 Player 添加一个力使其运动，力的大小我们可以在 Unity 编辑器中编辑 //这里再乘以一个Time.deltaTime是为了使 Player 完成的是每秒移动 speed 米，而不是每帧 speed 米，你们可以试试将这个Time.detalTime删去后 Player 的运行效果 GetComponent&lt;Rigidbody&gt;().AddForce(movement * Time.deltaTime * speed); &#125;&#125; 脚本写完后记得保存一下，再来到我们的 Unity 编辑器中，选择 Player 物体后你会发现在脚本中多出来一个 Speed 项，这就是我们之前定义它为 public 公共项的作用了，我们将他设置值为120，然后点击 Unity 编辑器上方的播放按钮运行，之后我们就可以按 W、A、S、D 键来控制我们的 Player 运动了。 相机跟随让相机跟随 Player 一起运动，使相机和物体为关联关系但不是父子级别的关系，若是父子关系由于 Player 是球体运动时会滚动，所以相机也会随着 Player 的滚动而滚动，这不是我们需要的效果。 选择 Main Camera 物体用上文同样的方法添加 CameraController 脚本文件，然后拖至 Scripts文件夹中存放，双击脚本文件进行编辑。 脚本文件名：Camera Controller 代码如下： 123456789101112131415161718192021222324using System.Collections;using System.Collections.Generic;using UnityEngine;public class CameraController : MonoBehaviour &#123;//创建一个公共的游戏物体，在Unity编辑器中可以将一个物体拖至脚本处的 player 的框中，脚本中就可以直接获取此物体，就不需要查找的步骤//此处的功能就是将我们需要摄像机跟随的物体添加进去，也就是 Playerpublic GameObject player;//创建一个变量，用来存储摄像机与物体 Player 未知的默认的差值private Vector3 offSet;private void Start()&#123; //我们给 offSet 赋值，值的的大小为摄像机的 Position 三维向量的值减去 物体 Position 三维向量的值，也就是相机与物体之间的距离 offSet = transform.position - player.transform.position;&#125;private void LateUpdate()&#123; //使我们的相机的位置永远位于物体的位置+ offSet 这个差值 transform.position = player.transform.position + offSet;&#125;&#125; 脚本编写完后我们来到 Unity3D编辑器，选择 Main Camera 物体文件后会发现在脚本下方出现了一个叫 Player 的项，我们可以吧 Player 物体拖至后方的框子中，然后运行移动 Player 就会发现摄像机也在跟随着 Player 一起运动。 Pick Up 的自转这次我们要完成的是将 Pick Up 旋转起来。 选择 Prefabes 中的 Pickup 物体，添加名为 Rotation 的脚本文件后拖至 Scripts 文件夹中，然后双击我们的脚本文件编辑我们的脚本。 脚本文件名： Rotation 代码如下： 12345678910using System.Collections;using System.Collections.Generic;using UnityEngine;public class Rotation : MonoBehaviour &#123;private void FixedUpdate()&#123; transform.Rotate(new Vector3(15, 30, 45) * Time.deltaTime);&#125;&#125; 回到 Unity 编辑器运行我们的游戏就可以看到 Pickup 开始自己转了起来。 UI 的控制打开我们的 PlayerController 脚本，我们在其中编辑 UI 的控制脚本。 脚本文件名：PlayerController 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869using System.Collections;using System.Collections.Generic;using UnityEngine;//切记一定要调用 UIusing UnityEngine.UI;public class PlayerController : MonoBehaviour &#123;//public 公共的，会使此变量显示在 unity 编辑器中方便我们调节数值//此处定义一个 speed 变量是为了控制 Player 的运动速度public float speed;//获取我们创建的 CountTextpublic Text countText;//获取我们的创建的 WinTextpublic Text winText;//定义个变量记录我们的得分private int count;public void Start()&#123; //调用我们的自定义函数 SetCount SetCount(); //初始化我们的winText里的文本为空，功能相当于隐藏了此文本 winText.text = "";&#125;public void FixedUpdate()&#123; //获取横向要使 Player 位移的量 float moveHorizontal = Input.GetAxis("Horizontal"); //获取纵向要使 Player 位移的量 float moveVertical = Input.GetAxis("Vertical"); //定义一个新的三维向量，来确定 Player 的运行方向 Vector3 movement = new Vector3(moveHorizontal, 0.0f, moveVertical); //给 Player 添加一个力使其运动，力的大小我们可以在 Unity 编辑器中编辑 //这里再乘以一个Time.deltaTime是为了使 Player 完成的是每秒移动 speed 米，而不是每帧 speed 米，你们可以试试将这个Time.detalTime删去后 Player 的运行效果 GetComponent&lt;Rigidbody&gt;().AddForce(movement * Time.deltaTime * speed);&#125;private void OnTriggerEnter(Collider other)&#123; //当 Player 碰到了物体的 Tag 名为 PickUp 的物体时运行 if 的程序 //为何要加 Tag呢？因为 Player 在运行中会碰到很多东西，比如：地面、墙壁，这些都不是我想要销毁的物体，所以我们给我们需要销毁的物体添加个“名字” if (other.gameObject.tag == "PickUp") &#123; //销毁 Pickup Destroy(other.gameObject); //分数+1 count += 1; //更新 CountText 的文本内容 SetCount(); //当我们的分数大于我们定义的 Pickup 的个数(因为我创建了8个 Pickup，所以我的是 count &gt;= 8) if (count &gt;= 8) &#123; //给我们的 WinText 的文本内添加获胜内容，其功能也就是显示获胜信息 winText.text = "You Win!"; &#125; &#125;&#125;public void SetCount()&#123; //使我们的 CountText 显示分数，其格式为 Count：[分数] countText.text = "Count:" + count;&#125;&#125; 保存我们的代码并打开 Unity 编辑器，选择 Player 物体后将我们的创建的 CountText 和 WinText 物体拖至 PlayerCOntroller 脚本下方相对应的地方，然后运行我们的游戏，此时我们的 Roll a ball 的游戏已经制作完成了。 总结 我们写完代码一定要记得将我们需要使用到的物体挂上，不然运行时没有效果或者报错。 Tag 的添加一定要注意自己的大小写，在脚本添加中判断物体的 Tag 时一定要与我们创建的 Tag 完全一样。 其中游戏的实现可能会有很多种方法，自己可以翻阅 Unity 官方的脚本文档然后去尝试使用其他的一些方法来实现我们的游戏。 如果自己有能力，可以尝试改编游戏加入自己的想法，然后一一去实现它，这样对于我们的游戏开发很有帮助。 游戏开发其实很简单，但是如果想要真正的在这个领域成为“大牛”级别的人物，还需要很多很多的努力，我们一起坚持，一起努力！ 欢迎大家收藏我的博客，我会努力更新更多的作品的，给自己加个油！]]></content>
      <categories>
        <category>教程</category>
        <category>Unity</category>
        <category>官方案例</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>官方案例</tag>
        <tag>Roll a ball</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atom 插件备份--Sync Setting]]></title>
    <url>%2F2018%2F11%2F15%2FAtom-%E6%8F%92%E4%BB%B6%E5%A4%87%E4%BB%BD-Sync-Setting%2F</url>
    <content type="text"><![CDATA[当我们使用的 Atom 插件装的越来越多，相关的配置也越来越个性化，一旦我们的电脑重装后就需要重新安装我们的开发环境，这将会是一件令人头疼的事情，但是现在我发现了一款备份的插件推荐给大家，它就是--Sync Setting。 安装打开我们的 Atom 在菜单栏 File 中找到 Settings 选项，选中的 Install 界面中搜索 Sync Setting 插件，然后点击 install 下载即可,之后可以在 Packages 中找打我们下载的所有插件。 配置 首先我们打开 Sync Setting 的插件配置界面看到，我们需要填写两个内容才可以备份，下面我就一步一步的教大家如何去完成。 第一步：创建 personal access token 打开我们的 GitHub，点击我们的头像选择 Settings 选项，在 Settings 界面中选择 Developer Settings，然后就看到我们需要找到的 Personal access tokens,然后点击右上角的 Generate new token 创建。 注：一定要记得勾选gist选项 点击左下角的 Generate token 创建，然后复制生成的 token 序列粘贴到 Sync Setting 配置界面图中的第一个输入框中。 第二步：创建 gist 还是点击我们的头像，选择 Your gists 后在输入框中随便输入点信息，然后点击 Create secret gist 创建一个gist。 gist创建成功后，我们复制生成的 gistID 将其粘贴到Sync Setting 配置界面图中的第二个输入框中。 以上就是我们的 Sync Setting 所有的配置操作了，那我们该如何备份呢？ 注：最好将两个数据备份一下，以便以后恢复用到。若没有备份需要恢复，可以看文章最下方的教程 备份打开我们 Atom 的文档编辑页面（Crtl + Shift + P），在其中输入”Syn”选中第二个 Backup 选项就可以开始备份了。 ../imgs/img_01/img07.png当 Atom 编辑器右上角出现绿色的备份成功的提示消息，就意味着我们的备份成功啦。 恢复(备份)在新的 Atom 编辑器中下载 Sync Setting 插件，在其配置界面中将我们备份的两个数据分别填入两个输入框中，打开我们 Atom 的文档编辑页面（Crtl + Shift + P），在其中输入”Syn”选中第三个 Restore 选项就可以恢复了。 恢复(未备份)我们缺的就是两个数据就可以完成ifu操作了，所以我们只需要想方法获取到这两个数据就可以了。 personal access token打开我们的 GitHub 找到我们之前创建的 personal access token(在Settings中,前面写的很详细)，然后会看到有个红色字体的按钮，它的意思是重新生成令牌，我们就可以重新生成一个令牌。 GistID打开我们的 GitHub 还是选择 Your gists 到达我们的 gist 的界面，然后选择我们的右上角的 See all of your gists ，找到我们之前创建的 gist。 然后我们点击 init.coffee，就到达了我们备份 Atom 插件信息的一个库. 之后我们以发现我们所需要的 gistID 就在我们的网址结尾处，直接将他复制过去即可。 现在我们所需要的两个数据全都有了，就可以开始我们的恢复操作了，不过在此还是推荐各位朋友记得备份一下，免得花这么多时间去找。 欢迎大家收藏我的博客，我会努力更新更多的作品的，给自己加个油！]]></content>
      <categories>
        <category>教程</category>
        <category>Atom</category>
        <category>Sync Setting 备份插件</category>
      </categories>
      <tags>
        <tag>Atom</tag>
        <tag>插件</tag>
        <tag>教程</tag>
        <tag>Sync Setting</tag>
        <tag>备份</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 的使用]]></title>
    <url>%2F2018%2F11%2F15%2FMarkdown%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Markdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 Markdown语法介绍段落与换行Markdown 中的段落指连续的一段文字，编写时段落之间用至少一个空行隔开，段落内多个空格将被视为一个空格，段首不支持缩进。 如果想要在显示时显示多个空行，可以插入 &lt;br/&gt; 来实现，注意的是，插入的 &lt;br/&gt; 应与前后的段落中间至少空一行。 标题这是最为常用的格式，在平时常用的的文本编辑器中大多是这样实现的：输入文本、选中文本、设置标题格式。 12345678910111213Markdown支持两种类型的标题,例如：//类型 1这是一级标题==========这是二级标题----------//类型 2# 这是一级标题## 这是二级标题...###### 这是六级标题 从上面可以看出类型 1 是在标题下面插入 = 或者 - 来标识标题等级，但局限是其只能表示两个级别的标题。 类型 2 是在标题前面插入 1 - 6 个 # ，表示 6 个等级的标题，这是比较推荐的用法。 注：# 和「一级标题」之间建议保留一个字符的空格，这是最标准的 Markdown 写法。 列表列表格式也很常用，在 Markdown 中，你只需要在文字前面加上 -、+或 * 就可以了，例如： 123- 文本1- 文本2- 文本3 上面的 - 可以用 +、*替换。需要注意的是，- 等符号与后面的文字至少空一格空格。 如果你希望有序列表，也可以在文字前面加上 1. 2. 3. 就可以了，例如： 1231. 文本12. 文本23. 文本3 同无序列表一样，标记符号与后面的文字至少空一格空格。但编辑时的数字对显示无影响。 代码区块缩进 4 个空格，需要注意的是，每行代码都需要至少缩进 4 个空格，不能像段落一样采用首行标记的偷懒写法，一个代码区会一直持续到没有缩进 4 个空格的那一行。 也可以用一对三个连续的撇号 ` 来包裹代码段，例如： 1这是一个代码区块。 有的解释器还能根据代码的语言从而给代码加上语法高亮，例如： 1function func() &#123;&#125; 分割线使用三个及以上的 *、 -或 _来表示一个分割线，符号不能混用，符号之间可以插入多个空格。需要注意的是，使用 - 来插入分割线时需要与上一个段落至少空一行，否则 Markdown 会将上一行文字解释为二级标题。 表格表格是 Markdown 比较复杂的一种表示，例如： 12345| Table | Col1 | Col2 || ----- |:----:| ----:|| Row1 | 1-1 | 1-2 || Row2 | 2-1 | 2-2 || Row3 | 3-1 | 3-2 | 注：上面第二行中的点代表对齐方式，分别是默认（居左）、居中、居右。 超链接Markdown 中有三种方式实现超链接,例如： 12//方式 1[百度](http://www.baidu.com) 方式 1 较为常用，也可以为链接的文字加上提示文字，只要在括号中超链接加上空格后添加提示内容即可，例如： 1[百度](http://www.baidu.com "这是提示文字") 方式 2 由链接文字和链接地址组成，不同的是两者均由 [] 包裹。链接地址的格式为： 方括号，里面输入链接地址； 紧接着是一个冒号； 冒号后面至少一个空格； 链接地址； 若有提示文字，空格后用引号或者括号包裹提示文字。 下面是完整示例： 123//方式 2[百度][Baidu-url][Baidu-url]: http://www.baidu.com 第三种方式是用 &lt;&gt; 来包裹 URL。 12//方式 3&lt;http://www.baidu.com&gt; 加粗和斜体Markdown 使用 * 和 _ 来表示粗体和斜体,例如： 1234567//加粗**这是加粗文字**__这也是加粗文字__//斜体*这是斜体文字*_这也是斜体文字_ 被偶数个 * 或 _ 包裹的文字显示加粗效果，被奇数个包裹的为倾斜效果。 需要注意的是，* 和 - 要成对出现，不能混合使用，也不能只出现一个。同时，标识符号要与标识的文字紧挨着，符号与符号之间、符号文字之间不能有任何空格。 代码使用 ` (撇号) 来包裹一小段代码，例如： 1'hello world' 若想在代码中添加撇号，可以使用多个撇号包裹里面需要添加的撇号，但注意里面的连续的撇号数量不能超过外面的数量,例如: 12//显示一个撇号`` ` `` 图片图片的插入方式跟超链接前两种插入方式类似，例如： 123456//方式 1![如果图片不能显示，就显示这段文字](图片 url)//方式 2![如果图片不能显示，就显示这段文字][Image-url][Image-url]: 图片url "这是提示文字" 反斜杠我们经常需要在文章中插入一些特殊符号，而这些符号恰好是前面所讲的标识符号，可以在特殊符号前插入 \ 来直接显示符号，而不让 Markdown 来将其解释为标识符号。 Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： 123456789101112\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 Markdown编辑器支持Markdown的编辑器有好多，功能也不完全一致，有的是用来进行基本的写作，有的是用来写代码的，有的甚至只是博客平台配套的编辑器。 我个人用过一个都很不错，在这儿推荐一下 windows Markdown Pad 2（Pro版要收费，网上有注册码） Atom （个人主推，免费，颜值高，还可以安装各式各样的插件） Mac MacDown 欢迎大家收藏我的博客，我会努力更新更多的作品的，给自己加个油！]]></content>
      <categories>
        <category>教程</category>
        <category>Markdown语法</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Markdown</tag>
        <tag>语法</tag>
      </tags>
  </entry>
</search>
