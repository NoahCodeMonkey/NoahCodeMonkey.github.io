<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2015届蓝桥杯 Java C组 省赛试题及答案]]></title>
    <url>%2F2019%2F03%2F05%2F2015%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF-Java-C%E7%BB%84-%E7%9C%81%E8%B5%9B%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%2F</url>
    <content type="text"><![CDATA[因为今年3月份要参加这一届的蓝桥杯比赛，为此刷真题并写下一些文章留些记录，不管最后的成绩如何，我努力了！加油！！！ 结果填空1隔行变色题目 Excel 表的格子很多，为了避免把某行的数据和相邻行混淆，可以采用隔行变色的样式。 小明设计的样式为：第1行蓝色，第2行白色，第3行蓝色，第4行白色，…. 现在小明想知道，从第21行到第50行一共包含了多少个蓝色的行。 请你直接提交这个整数，千万不要填写任何多余的内容。 思路 由题可知，颜色的变化是由行号的奇偶性来判断的，所以我们只需要在给定的范围内循环一下，在循环中加入一个 if判断是奇是偶，因为题目只需要输出蓝色行的个数，我们就可以判断它是否为奇数，若是奇数则次数加1即可. 答案 15 代码 123456789101112131415161718 import java.util.Scanner;public class _01 &#123; public static void main(String[] args) &#123; Scanner s1 = new Scanner(System.in); int start = s1.nextInt(); int end = s1.nextInt(); int count = 0; for (int i = start; i &lt;= end; i++) &#123; if (i % 2 != 0) &#123; count++; &#125; &#125; System.out.println(count); &#125;&#125; 立方尾不变题目有些数字的立方的末尾正好是该数字本身。比如：1,4,5,6,9,24,25,…. 请你计算一下，在10000以内的数字中（指该数字，并非它立方后的数值），符合这个特征的正整数一共有多少个。 请提交该整数，不要填写任何多余的内容。 思路一开始我想的很简单，就是单纯的拿10000的 for 循环中判断 i == Math.pow(i, 3) % 10 ,之后看见题目中举得例子不止我用上面代码测试出的5这个结果,发现他的结尾不一定是就是最后一位啊,应该 i 是几位它的结尾就该留几位,为了解决这个问题,我想到的是用 String 的 length 方法,详情请看代码. 答案36 代码123456789101112131415161718public class Main &#123; public static void main(String[] args) &#123; int count = 0; for (int i = 1; i &lt;= 10000; i++) &#123; String str = "" + i; int yu = 1; for (int j = 0; j &lt; str.length(); j++) &#123; yu *= 10; &#125; if (i == Math.pow(i, 3) % yu) &#123; count++; &#125; &#125; System.out.println(count); &#125;&#125; 无穷分数题目无穷的分数，有时会趋向于固定的数字。 请计算【图1.jpg】所示的无穷分数，要求四舍五入，精确到小数点后5位，小数位不足的补0。 请填写该浮点数，不能填写任何多余的内容。 思路首先,很明显一看到这个题目我就想到了用递归做,但是细看了题目以后,发现有点看不懂了,他为什么没有规定出口值?那他不还要一直循环下去嘛?那这结果怎么求嘛?无奈之下,从网上查找了答案,才清楚这题目的意思,原来它的结果会随着运算的次数越多,会越来越精确一个值,我们只需要把那个大约值求出来即可. 答案0.58198 代码1234567891011121314public class Main &#123; public static void main(String[] args) &#123; System.out.printf("%.5f", FS(1)); &#125; public static double FS(double n) &#123; if (n &gt;= 100) &#123; return n; &#125; else &#123; return n / (n + FS(n + 1)); &#125; &#125;&#125; 代码填空循环节长度题目两个整数做除法，有时会产生循环小数，其循环部分称为：循环节。比如，11/13=6=&gt;0.846153846153….. 其循环节为[846153] 共有6位。下面的方法，可以求出循环节的长度。 请仔细阅读代码，并填写划线部分缺少的代码。1234567891011121314public static int f(int n, int m)&#123; n = n % m; Vector v = new Vector(); for(;;) &#123; v.add(n); n *= 10; n = n % m; if(n==0) return 0; if(v.indexOf(n)&gt;=0) _________________________________ ; //填空 &#125;&#125; 注意，只能填写缺少的部分，不要重复抄写已有代码。不要填写任何多余的文字。 思路这道题,一上来其实已经想到了如何解决,但是自己太蠢,唉,服了!!!一上来我就把代码放到eclipse中运行,把需要填空的地方我改成了让它输出 v.indexOf ,果不其然答案就在其中,看到结果一直在循环0-5,这不就是答案了嘛,然后我就使劲想啊想啊,想不懂怎么把他们搞出来,总想着把5能取出来最后加1啥的乱七八糟的东西,无奈毫无进展,只好从网上寻找答案,当看到答案时心都凉了一半,这么简单为啥就是想不到… 答案return v.size(); 代码12345678910111213141516171819202122232425import java.util.Vector;public class Main &#123; public static void main(String[] args) &#123; System.out.println(f(11, 13)); &#125; public static int f(int n, int m) &#123; n = n % m; Vector v = new Vector(); for (;;) &#123; v.add(n); n *= 10; n = n % m; if (n == 0) return 0; if (v.indexOf(n) &gt;= 0) &#123; return v.size(); &#125; &#125; &#125;&#125; 格子中输出题目stringInGrid方法会在一个指定大小的格子中打印指定的字符串。要求字符串在水平、垂直两个方向上都居中。如果字符串太长，就截断。如果不能恰好居中，可以稍稍偏左或者偏上一点。 下面的程序实现这个逻辑，请填写划线部分缺少的代码。 123456789101112131415161718192021222324252627282930public static void stringInGrid(int width, int height, String s)&#123; if(s.length()&gt;width-2) s = s.substring(0,width-2); System.out.print("+"); for(int i=0;i&lt;width-2;i++) System.out.print("-"); System.out.println("+"); for(int k=1; k&lt;(height-1)/2;k++)&#123; System.out.print("|"); for(int i=0;i&lt;width-2;i++) System.out.print(" "); System.out.println("|"); &#125; System.out.print("|"); String ff = _______________________________________________________; //填空 System.out.print(String.format(ff,"",s,"")); System.out.println("|"); for(int k=(height-1)/2+1; k&lt;height-1; k++)&#123; System.out.print("|"); for(int i=0;i&lt;width-2;i++) System.out.print(" "); System.out.println("|"); &#125; System.out.print("+"); for(int i=0;i&lt;width-2;i++) System.out.print("-"); System.out.println("+");&#125; 对于题目中数据，应该输出：123456+------------------+| || abcd1234 || || |+------------------+ （如果出现对齐问题，参看【图1.jpg】） 思路一开始遇到这题一脸蒙,首先时不知道String.format的作用,查了API和网上资料搜索之后才知道，这个就是C语言的输出格式嘛，但是当我试了一下填入 “%s%s%s” 虽然值是在格子中输出出来了，但是并没有居中，这可咋整？然后直接在网上查找原题，但看到的都是C语言版的不过也看出了一下名堂，在 %s 中间居然可以添加一个整数来控制它前面的空格数，然后我就将其更改为 “%” + (width - s.length()) / 2 + “s%s%” + (width - s.length()) / 2 + “s”; ，谁知运行后还是显示不对，原来是我忘了两边还有一个 | 也要算进去。 答案“%” + (width - s.length() - 2) / 2 + “s%s%” + (width - s.length() - 2) / 2 + “s”; 代码123456789101112131415161718192021222324252627282930313233343536373839404142public class Main &#123; public static void main(String[] args) &#123; stringInGrid(20, 6, "abcd1234"); &#125; public static void stringInGrid(int width, int height, String s) &#123; if (s.length() &gt; width - 2) s = s.substring(0, width - 2); System.out.print("+"); for (int i = 0; i &lt; width - 2; i++) System.out.print("-"); System.out.println("+"); for (int k = 1; k &lt; (height - 1) / 2; k++) &#123; System.out.print("|"); for (int i = 0; i &lt; width - 2; i++) System.out.print(" "); System.out.println("|"); &#125; System.out.print("|"); String ff = "%" + (width - s.length() - 2) / 2 + "s%s%" + (width - s.length() - 2) / 2 + "s";// 填空 System.out.print(String.format(ff, "", s, "")); System.out.println("|"); for (int k = (height - 1) / 2 + 1; k &lt; height - 1; k++) &#123; System.out.print("|"); for (int i = 0; i &lt; width - 2; i++) System.out.print(" "); System.out.println("|"); &#125; System.out.print("+"); for (int i = 0; i &lt; width - 2; i++) System.out.print("-"); System.out.println("+"); &#125;&#125; 结果填空题2奇妙的数字题目小明发现了一个奇妙的数字。它的平方和立方正好把0~9的10个数字每个用且只用了一次。你能猜出这个数字是多少吗？ 请填写该数字，不要填写任何多余的内容。 思路看到这题目想到的就是 for 循环遍历数字，然后计算它的平方和立方再去判断它们刚好使用0-9这10个数各一次。一开始我计算他们的平方和立方时选择的是使用Math.pow()这个方法，但是它返回值是double类型的，之后求它的长度时会有影响，所以我还是改成了最传统的相乘，多说无益，直接上代码吧。 答案69 代码123456789101112131415161718192021222324public class Main &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 100; i++) &#123; int pf = i * i; int lf = i * i * i; String str = pf + " " + lf; if (PD(str) &amp;&amp; (String.valueOf(pf).length() + String.valueOf(lf).length() == 10)) &#123; System.out.println(i); break; &#125; &#125; &#125; public static boolean PD(String str) &#123; if (str.contains("1") &amp;&amp; str.contains("2") &amp;&amp; str.contains("3") &amp;&amp; str.contains("4") &amp;&amp; str.contains("5") &amp;&amp; str.contains("6") &amp;&amp; str.contains("7") &amp;&amp; str.contains("8") &amp;&amp; str.contains("9") &amp;&amp; str.contains("0")) &#123; return true; &#125; return false; &#125;&#125; 加法变乘法题目我们都知道：1+2+3+ … + 49 = 1225现在要求你把其中两个不相邻的加号变成乘号，使得结果为2015 比如：1+2+3+…+10*11+12+…+27*28+29+…+49 = 2015就是符合要求的答案。 请你寻找另外一个可能的答案，并把位置靠前的那个乘号左边的数字提交（对于示例，就是提交10）。 注意：需要你提交的是一个整数，不要填写任何多余的内容。 思路一开始我想到的方法就是建立一个数组，然后靠两个不相邻的两组相乘数减去这两组数的相加之后的和，让其结果等于2015-1225即可，但之后我一直遇到的问题就是结果不一样，我还在哪儿找了半天原因，但感觉自己的想法真的没有错误啊，为啥答案就是不一样？然后找网上的答案，才发现完全可以直接两个 for 循环嵌套即可，完全没必要在搞个数组画蛇添足了，看了一下他们的代码，和我的想法一样啊为啥我的就是错的？整了半天终于找出了原因，因为我数组是从0开始赋值的，最后答案要加1就正确了。。。。 代码1234567891011121314151617public class Main &#123; public static void main(String[] args) &#123; end: for (int i = 1; i &lt;= 47; i++) &#123; for (int j = 3; j &lt; 49; j++) &#123; if (i * (i + 1) + j * (j + 1) - i - (i + 1) - j - (j + 1) == 2015 - 1225) &#123; if (i == 10) &#123; continue; &#125; System.out.println(i); break end; &#125; &#125; &#125; &#125;&#125; 移动距离题目X星球居民小区的楼房全是一样的，并且按矩阵样式排列。其楼房的编号为1,2,3…当排满一行时，从下一行相邻的楼往反方向排号。比如：当小区排号宽度为6时，开始情形如下： 1 2 3 4 5 612 11 10 9 8 713 14 15 ….. 我们的问题是：已知了两个楼号m和n，需要求出它们之间的最短移动距离（不能斜线方向移动） 输入为3个整数w m n，空格分开，都在1到10000范围内要求输出一个整数，表示m n 两楼间最短移动距离。 例如：用户输入：6 8 2则，程序应该输出：4 再例如：用户输入：4 7 20则，程序应该输出：5 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 1000ms 请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。 所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。注意：不要使用package语句。不要使用jdk1.7及以上版本的特性。注意：主类的名字必须是：Main，否则按无效代码处理。 思路这道题乍一看很简单，但是开始做之后就开始各种问题出现，我感觉不做过多解释了吧，这题需要去理解我就直接呈上我的代码了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142public class Main &#123; public static void main(String[] args) &#123; Scanner s1 = new Scanner(System.in); int w = s1.nextInt(); int m = s1.nextInt(); int n = s1.nextInt(); int cha = 0, newNum = 0, sum = 0; int max1 = initMax(w, Math.min(m, n)); int min1 = max1 - 5; int max2 = initMax(w, Math.max(m, n)); int min2 = max2 - 5; if (isJI(w, max1)) &#123; cha = Math.min(m, n) - min1; &#125; else &#123; cha = max1 - Math.min(m, n); &#125; if (isJI(w, max2)) &#123; newNum = min2 + cha; &#125; else &#123; newNum = max2 - cha; &#125; System.out.println(max1 + " " + max2); System.out.println(Math.abs(Math.max(m, n) - newNum) + " " + (max2 / max1 - 1)); sum = Math.abs(Math.max(m, n) - newNum) + max2 / max1 - 1; System.out.println(sum); &#125; public static int initMax(int w, int n) &#123; int tmp = w; while (w &lt; n) &#123; w += tmp; &#125; return w; &#125; public static boolean isJI(int w, int n) &#123; if (n / w % 2 != 0) &#123; return true; &#125; return false; &#125;&#125; 打印大X题目小明希望用星号拼凑，打印出一个大X，他要求能够控制笔画的宽度和整个字的高度。为了便于比对空格，所有的空白位置都以句点符来代替。 要求输入两个整数m n，表示笔的宽度，X的高度。用空格分开(0&lt;m&lt;n, 3&lt;n&lt;1000, 保证n是奇数)要求输出一个大X 例如，用户输入：3 9程序应该输出： 123456789***.....***.***...***...***.***.....*****.......***.......*****.....***.***...***...***.***.....*** （如有对齐问题，参看【图1.jpg】） 再例如，用户输入：4 21程序应该输出 123456789101112131415161718192021****................****.****..............****...****............****.....****..........****.......****........****.........****......****...........****....****.............****..****...............********.................******...................****...................******.................********...............****..****.............****....****...........****......****.........****........****.......****..........****.....****............****...****..............****.****................**** （如有对齐问题，参看【图2.jpg】） 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 1000ms 请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。 所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。注意：不要使用package语句。不要使用jdk1.7及以上版本的特性。注意：主类的名字必须是：Main，否则按无效代码处理。 思路这种打印类型的题目都得靠找规律去完成，像本题因为他是一个上下对称图形，所以我们可以分开为上下两半完成即可，比赛中我们只需将所有精力放在上半部分，当我们把上半部分完成后就可以，下半部分只需要复制一下再改几个值即可。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Main &#123; public static void main(String[] args) &#123; Scanner s1 = new Scanner(System.in); // 笔的宽度 int m = s1.nextInt(); // x的高度 int n = s1.nextInt(); // 列数 int y = m + n - 1; // 上半段 for (int a = 0; a &lt; (n + 1) / 2; a++) &#123; int count = (y - 2 * m) - a * 2; for (int i = 0; i &lt; a; i++) &#123; System.out.print("."); &#125; for (int i = 0; i &lt; m; i++) &#123; System.out.print("*"); &#125; for (int i = count - 1; i &gt;= 0; i--) &#123; System.out.print("."); &#125; if (count &gt;= 0) &#123; for (int i = 0; i &lt; y - (2 * a + m) - count; i++) &#123; System.out.print("*"); &#125; &#125; else &#123; for (int i = 0; i &lt; y - (2 * a + m); i++) &#123; System.out.print("*"); &#125; &#125; for (int i = 0; i &lt; a; i++) &#123; System.out.print("."); &#125; System.out.println(); &#125; // 下半段 for (int a = (n + 1) / 2 - 1; a &gt;= 0; a--) &#123; int count = (y - 2 * m) - a * 2; for (int i = 0; i &lt; a; i++) &#123; System.out.print("."); &#125; for (int i = 0; i &lt; m; i++) &#123; System.out.print("*"); &#125; for (int i = count - 1; i &gt;= 0; i--) &#123; System.out.print("."); &#125; if (count &gt;= 0) &#123; for (int i = 0; i &lt; y - (2 * a + m) - count; i++) &#123; System.out.print("*"); &#125; &#125; else &#123; for (int i = 0; i &lt; y - (2 * a + m); i++) &#123; System.out.print("*"); &#125; &#125; for (int i = 0; i &lt; a; i++) &#123; System.out.print("."); &#125; System.out.println(); &#125; &#125;&#125; 垒骰子题目赌圣atm晚年迷恋上了垒骰子，就是把骰子一个垒在另一个上边，不能歪歪扭扭，要垒成方柱体。经过长期观察，atm 发现了稳定骰子的奥秘：有些数字的面贴着会互相排斥！我们先来规范一下骰子：1 的对面是 4，2 的对面是 5，3 的对面是 6。假设有 m 组互斥现象，每组中的那两个数字的面紧贴在一起，骰子就不能稳定的垒起来。 atm想计算一下有多少种不同的可能的垒骰子方式。两种垒骰子方式相同，当且仅当这两种方式中对应高度的骰子的对应数字的朝向都相同。由于方案数可能过多，请输出模 10^9 + 7 的结果。 不要小看了 atm 的骰子数量哦～ 「输入格式」第一行两个整数 n mn表示骰子数目接下来 m 行，每行两个整数 a b ，表示 a 和 b 不能紧贴在一起。 「输出格式」一行一个数，表示答案模 10^9 + 7 的结果。 「样例输入」2 11 2 「样例输出」544 「数据范围」对于 30% 的数据：n &lt;= 5对于 60% 的数据：n &lt;= 100对于 100% 的数据：0 &lt; n &lt;= 10^9, m &lt;= 36 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 2000ms 请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。 所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。注意：不要使用package语句。不要使用jdk1.7及以上版本的特性。注意：主类的名字必须是：Main，否则按无效代码处理。 思路动态规划题。。。。不会不会不会，递归都有时候绕不出来的我，对动态规划充满了阴影，但没办法呀，去网上找资料死磕了。 代码这题我选择先放放再刷其他题了，但在此处提供自认为写得很详细的一位博主的文章，有时间可以去看看研究。 JacobKong_Dev的简书]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>省赛</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>2015届</tag>
        <tag>蓝桥杯</tag>
        <tag>Java</tag>
        <tag>C组</tag>
        <tag>省赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity 官方案例进阶--Roll a ball]]></title>
    <url>%2F2018%2F11%2F15%2FUnity%E5%AE%98%E6%96%B9%E6%A1%88%E4%BE%8B%E8%BF%9B%E9%98%B6-Roll-a-ball%2F</url>
    <content type="text"><![CDATA[经过上一次的学习，我又想改进一下这款 Roll a ball 游戏，首先这款游戏只有胜利没有失败，所以我想定义一个条件来控制它的输赢，因此我想到了如下的方案：使我们的玩家控制 Player 在规定时间内达到一定的分数就胜利，反之则失败 任务目标这里只是大概的目标内容，还有一些细节会在后面完成的时候体现出来。 完成 PickUp 的随机刷新出现，每隔3秒刷新一个 做一个倒计时器用于显示游戏剩余时间 控制分数和时间，若玩家在规定时间内达到分数则显示 You Win！字样，Player 禁止移动；若失败，则小球爆炸并显示 Game Over！ 字样。 环境搭建主体还是 Roll a ball 的内容，其中有一些小改动，我们在此完成一下。 删除场景中的所有 PickUp因为我们要完成的是随机刷新 PickUp 物体，所以我们不需要在场景中添加 PickUp 物体，到时候会用到一个新的知识来完成我们的随机显示 PickUp 物体的操作。 添加倒计时文本因为我们需要让玩家知道游戏的剩余时间，所以我们需要添加一个用来显示时间的文本，位置我选择在了中间顶部的位置，其他设置随意。 细节修改因为最终我们显示的文本不再是只有胜利，所以将我们之前创建的 WinText 改名为 ResultText。 遗漏补充在官方的案例中，PickUp 是有一个黄色的材质，而我在之前做的项目中忘记添加了，所以我现在添加了一个黄色材质球给我们的 PickUp。 以上就是我们的环境搭建相关的操作，下面就要开始我们的脚本编写，来实现游戏的运行了。 游戏运行修改以及准备我将 PlayerController 中除了将 Player 运动的脚本其余的都删除了。 脚本文件名：PlayerController 代码如下： using System.Collections; using System.Collections.Generic; using UnityEngine; public class PlayerController : MonoBehaviour { public float speed; private float moveHorizontal; private float moveVertical; private Vector3 movement; private void FixedUpdate() { moveHorizontal = Input.GetAxis(&quot;Horizontal&quot;); moveVertical = Input.GetAxis(&quot;Vertical&quot;); movement = new Vector3(moveHorizontal, 0.0f, moveVertical); GetComponent&lt;Rigidbody&gt;().AddForce(movement * speed * Time.deltaTime); } } 我将剩下的代码贴在上方了，有不清楚的或者项目删除了的可以直接复制过去。 创建 GameController 脚本还是在我们的 Player 物体上添加脚本取名为 GameController ，我定义它用来控制整个游戏的运行脚本，其实我们游戏的改变主要就是体现在此脚本的编写，所以当我们完成此脚本的编写也就意味着我们游戏的完成，废话不多说了下面我们就来完成它。 删除补回因为我们将原来 PlayerController 脚本中除了控制小球运动的代码都删除了，所以需要先补充一下 Planyer 与 PickUp 的碰撞以及分数控制的相关代码，此时只是补回后面还会有更改。 脚本文件名：GameController 代码如下： 123456789101112131415161718192021222324252627282930313233343536using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class GameController : MonoBehaviour &#123; public Text countText; private int count; private void Awake() &#123; count = 0; &#125; private void Start() &#123; SetCount(); &#125; private void OnTriggerEnter(Collider other) &#123; if (other.gameObject.tag == "PickUp") &#123; Destroy(other.gameObject); count++; SetCount(); &#125; &#125; void SetCount() &#123; countText.text = "Count:" + count; &#125;&#125; 目标一：刷新 PickUp 物体在此我们要完成的是让我们的 PickUp 物体在地面上的随机位置每3秒刷新一个。 这其中我们会用到几个新的知识，有需要的话最好还是去网上找找资料了解一下或者翻阅官网的API。 Clone 克隆物体 Randam 随机类 脚本文件名：GameController 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class GameController : MonoBehaviour &#123; public Text countText; //用于添加 PickUp 物体，之后克隆要用 public GameObject pickUp; private int count; //定义一个三维向量的值用于存储克隆物体的位置 private Vector3 newPickUpPt; //定义一个需要等待克隆物体的时间，根据目标应该赋值为3 private float fireRate; //定义一个下一次克隆物体的时间 private float nextFire; private void Awake() &#123; count = 0; //给 fireRate 赋值，控制克隆物体的间隔时间 fireRate = 3f; &#125; private void Start() &#123; SetCount(); &#125; private void Update() &#123; //判断游戏时间是否大于我们需要的它克隆的时间 if (Time.time &gt; nextFire) &#123; //计算下一次克隆时的时间 nextFire = Time.time + fireRate; //给我们的 PickUp 随机一个位置 newPickUpPt = new Vector3(Random.Range(-8, 8), 1f, Random.Range(-8, 8)); //这就是克隆的操作脚本了 //Instantiate(需要克隆的物体，克隆物体的 Pothion 值，克隆物体的 Rotation值) //此处我们要克隆的物体是 PickUp，他的位置就是我们之前随机存储的那个位置，Quaternion.identity 的意思是与原物体的 Rotation 值保持不变 Instantiate(pickUp, newPickUpPt, Quaternion.identity); &#125; &#125; private void OnTriggerEnter(Collider other) &#123; if (other.gameObject.tag == "PickUp") &#123; Destroy(other.gameObject); count++; SetCount(); &#125; &#125; void SetCount() &#123; countText.text = "Count:" + count; &#125;&#125; 脚本我们现在就写完了，保存一下脚本，然后来到我们的 Unity 编辑器中，给我们 Player 物体中的 GameController 脚本中的 Player 物体添加一下，然后运行就可以看到 PickUp 开始有规律的创建了。 控制倒计时器做倒计时器又需要用到一个新的知识–协程，这个知识还是很重要的，最好先去翻阅些资料了解一下它。 脚本文件名：GameController 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class GameController : MonoBehaviour &#123; public Text countText; //用于添加时间 Text 物体 public Text timeText; //用于添加 PickUp 物体，之后克隆要用 public GameObject pickUp; private int count; //定义一个三维向量的值用于存储克隆物体的位置 private Vector3 newPickUpPt; //定义一个需要等待克隆物体的时间，根据目标应该赋值为3 private float fireRate; //定义一个下一次克隆物体的时间 private float nextFire; private float time; private void Awake() &#123; count = 0; //给 fireRate 赋值，控制克隆物体的间隔时间 fireRate = 3f; time = 8; &#125; private void Start() &#123; SetCount(); //开始我们的协程 StartCoroutine(Timer()); &#125; private IEnumerator Timer() &#123; //定义一个循环，条件为要time&gt;0 while (time &gt; 0) &#123; //间隔1秒继续执行一下代码 yield return new WaitForSeconds(1); //time自减1 time--; //更新我们的时间文本 SetTime(); &#125; //结束我们的协程 StopCoroutine(Timer()); &#125; private void Update() &#123; //判断游戏时间是否大于我们需要的它克隆的时间 if (Time.time &gt; nextFire) &#123; //计算下一次克隆时的时间 nextFire = Time.time + fireRate; //给我们的 PickUp 随机一个位置 newPickUpPt = new Vector3(Random.Range(-8, 8), 1f, Random.Range(-8, 8)); //这就是克隆的操作脚本了 //Instantiate(需要克隆的物体，克隆物体的 Pothion 值，克隆物体的 Rotation值) //此处我们要克隆的物体是 PickUp，他的位置就是我们之前随机存储的那个位置，Quaternion.identity 的意思是与原物体的 Rotation 值保持不变 Instantiate(pickUp, newPickUpPt, Quaternion.identity); &#125; &#125; private void OnTriggerEnter(Collider other) &#123; if (other.gameObject.tag == "PickUp") &#123; Destroy(other.gameObject); count++; SetCount(); &#125; &#125; void SetCount() &#123; countText.text = "Count:" + count; &#125; void SetTime() &#123; timeText.text = time.ToString(); &#125;&#125; 控制结果方法挺多的，可以自己想想怎么去完成。 脚本文件名：GameController 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class GameController : MonoBehaviour &#123; public Text countText; //用于添加时间 Text 物体 public Text timeText; public Text resultText; //用于添加 PickUp 物体，之后克隆要用 public GameObject pickUp; private int count; //定义一个三维向量的值用于存储克隆物体的位置 private Vector3 newPickUpPt; //定义一个需要等待克隆物体的时间，根据目标应该赋值为3 private float fireRate; //定义一个下一次克隆物体的时间 private float nextFire; private float time; private void Awake() &#123; count = 0; //给 fireRate 赋值，控制克隆物体的间隔时间 fireRate = 3f; time = 8; &#125; private void Start() &#123; SetCount(); //开始我们的协程 StartCoroutine(Timer()); &#125; private IEnumerator Timer() &#123; //定义一个循环，条件为要time&gt;0 while (time &gt; 0) &#123; //间隔1秒继续执行一下代码 yield return new WaitForSeconds(1); //time自减1 time--; //更新我们的时间文本 SetTime(); //调用我们创建的控制结果函数 if (time &lt;= 0 &amp;&amp; count &lt; 2) &#123; resultText.text = "Game Over!"; &#125; else if (count &gt;= 2) &#123; resultText.text = "You Win!"; &#125; &#125; //结束我们的协程 StopCoroutine(Timer()); &#125; private void Update() &#123; //判断游戏时间是否大于我们需要的它克隆的时间 if (Time.time &gt; nextFire &amp;&amp; time &gt; 0) &#123; //计算下一次克隆时的时间 nextFire = Time.time + fireRate; //给我们的 PickUp 随机一个位置 newPickUpPt = new Vector3(Random.Range(-8, 8), 1f, Random.Range(-8, 8)); //这就是克隆的操作脚本了 //Instantiate(需要克隆的物体，克隆物体的 Pothion 值，克隆物体的 Rotation值) //此处我们要克隆的物体是 PickUp，他的位置就是我们之前随机存储的那个位置，Quaternion.identity 的意思是与原物体的 Rotation 值保持不变 Instantiate(pickUp, newPickUpPt, Quaternion.identity); &#125; &#125; private void OnTriggerEnter(Collider other) &#123; if (other.gameObject.tag == "PickUp") &#123; Destroy(other.gameObject); count++; SetCount(); &#125; &#125; void SetCount() &#123; countText.text = "Count:" + count; &#125; void SetTime() &#123; timeText.text = time.ToString(); &#125;&#125; 游戏的完善这是我们此游戏的最后部分，用于完善一些游戏中缺乏的地方，也添加了一些比较有意思的东西，来使游戏更加具有趣味性。 完善物体的克隆创建当游戏结束时，我们的克隆还在不停操作，这是我们不愿意看到的，所以接下来我们来完善它。 其实完善很简单，只需在我们克隆创建操作的 if 判断中添加条件就可以了。 脚本文件名：GameController 代码如下： 123456789101112131415private void Update() &#123; //判断游戏时间是否大于我们需要的它克隆的时间 if (Time.time &gt; nextFire &amp;&amp; time &gt; 0) &#123; //计算下一次克隆时的时间 nextFire = Time.time + fireRate; //给我们的 PickUp 随机一个位置 newPickUpPt = new Vector3(Random.Range(-8, 8), 1f, Random.Range(-8, 8)); //这就是克隆的操作脚本了 //Instantiate(需要克隆的物体，克隆物体的 Pothion 值，克隆物体的 Rotation值) //此处我们要克隆的物体是 PickUp，他的位置就是我们之前随机存储的那个位置，Quaternion.identity 的意思是与原物体的 Rotation 值保持不变 Instantiate(pickUp, newPickUpPt, Quaternion.identity); &#125; &#125; 完善倒计时器当我们游戏胜利后会发现我们的倒计时器依旧还在运行，所以这是有问题的，因此接下来我们就来完善它。 来到我们打代码，会发现我们的游戏胜利放在了倒计时器中的循环中，因此只要当我们胜利之后添加一个 个 Break 语句跳出循环就可以完成我们的倒计时停止的操作了。 脚本文件名：GmaeController 代买如下： 12345678910111213141516171819202122232425private IEnumerator Timer() &#123; //定义一个循环，条件为要time&gt;0 while (time &gt; 0) &#123; //间隔1秒继续执行一下代码 yield return new WaitForSeconds(1); //time自减1 time--; //更新我们的时间文本 SetTime(); //调用我们创建的控制结果函数 if (time &lt;= 0 &amp;&amp; count &lt; 2) &#123; resultText.text = "Game Over!"; &#125; else if (count &gt;= 2) &#123; resultText.text = "You Win!"; break; &#125; &#125; //结束我们的协程 StopCoroutine(Timer()); &#125; 写完代码后运行，然后完成我们的两个小球的条件后，会发现我们的倒计时停止了，耶！完成啦！但是我们又会惊喜的发现刚完成的游戏结束后停止创建物体的任务并没有完善，我们只考虑到了游戏失败时停止创建，若当游戏胜利结束时并没有考虑到，所以我们又要回过头来重新完善我们之前的任务。 补：完善物体的克隆创建要完善其实也很简单，只需要在我们创建的条件中再添加一个 Count 要小于我们的目标值就可以了。 脚本文件名： GameController 代码如下： 123456789101112131415private void Update() &#123; //判断游戏时间是否大于我们需要的它克隆的时间 if (Time.time &gt; nextFire &amp;&amp; time &gt; 0 &amp;&amp; count &lt; 2) &#123; //计算下一次克隆时的时间 nextFire = Time.time + fireRate; //给我们的 PickUp 随机一个位置 newPickUpPt = new Vector3(Random.Range(-8, 8), 1f, Random.Range(-8, 8)); //这就是克隆的操作脚本了 //Instantiate(需要克隆的物体，克隆物体的 Pothion 值，克隆物体的 Rotation值) //此处我们要克隆的物体是 PickUp，他的位置就是我们之前随机存储的那个位置，Quaternion.identity 的意思是与原物体的 Rotation 值保持不变 Instantiate(pickUp, newPickUpPt, Quaternion.identity); &#125; &#125; 趣味添加：游戏失败小球爆炸效果爆炸效果是从网上找的，在此感谢TPMer博主提供，爆炸效果需要用到的素材请到他的CSDN博客最底处下载。 TPMerd的CSDN博客 素材下载完成后记住他的下载位置当我们导入时需要用到，再打开我们的 Unity 编辑器在菜单栏中的 Assets 中找到 Import Package 再选择 Custom Package 选项来添加我们的素材，找到我们之前下载的素材包打开，在 Import Unity Package 界面中，我们勾去第一个 000.unity 场景文件后选择右下角的 Import 选项添加我们的素材。 然后编辑我们的脚本文件来完成我们的小球爆炸效果。 脚本文件名：GameController 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class GameController : MonoBehaviour &#123; public Text countText; //用于添加时间 Text 物体 public Text timeText; public Text resultText; //用于添加 PickUp 物体，之后克隆要用 public GameObject pickUp; //用于添加我们的爆炸物体 public GameObject Bang; private int count; //定义一个三维向量的值用于存储克隆物体的位置 private Vector3 newPickUpPt; //定义一个需要等待克隆物体的时间，根据目标应该赋值为3 private float fireRate; //定义一个下一次克隆物体的时间 private float nextFire; private float time; private void Awake() &#123; count = 0; //给 fireRate 赋值，控制克隆物体的间隔时间 fireRate = 3f; time = 8; &#125; private void Start() &#123; SetCount(); //开始我们的协程 StartCoroutine(Timer()); &#125; private IEnumerator Timer() &#123; //定义一个循环，条件为要time&gt;0 while (time &gt; 0) &#123; //间隔1秒继续执行一下代码 yield return new WaitForSeconds(1); //time自减1 time--; //更新我们的时间文本 SetTime(); //调用我们创建的控制结果函数 if (time &lt;= 0 &amp;&amp; count &lt; 2) &#123; resultText.text = "Game Over!"; //将 Player 物体销毁 Destroy(this.gameObject); //克隆我们的爆炸物体来代替我们的 Player 物体 Instantiate(Bang, this.transform.position, this.transform.rotation); &#125; else if (count &gt;= 2) &#123; resultText.text = "You Win!"; break; &#125; &#125; //结束我们的协程 StopCoroutine(Timer()); &#125; private void Update() &#123; //判断游戏时间是否大于我们需要的它克隆的时间 if (Time.time &gt; nextFire &amp;&amp; time &gt; 0 &amp;&amp; count &lt; 2) &#123; //计算下一次克隆时的时间 nextFire = Time.time + fireRate; //给我们的 PickUp 随机一个位置 newPickUpPt = new Vector3(Random.Range(-8, 8), 1f, Random.Range(-8, 8)); //这就是克隆的操作脚本了 //Instantiate(需要克隆的物体，克隆物体的 Pothion 值，克隆物体的 Rotation值) //此处我们要克隆的物体是 PickUp，他的位置就是我们之前随机存储的那个位置，Quaternion.identity 的意思是与原物体的 Rotation 值保持不变 Instantiate(pickUp, newPickUpPt, Quaternion.identity); &#125; &#125; private void OnTriggerEnter(Collider other) &#123; if (other.gameObject.tag == "PickUp") &#123; Destroy(other.gameObject); count++; SetCount(); &#125; &#125; void SetCount() &#123; countText.text = "Count:" + count; &#125; void SetTime() &#123; timeText.text = time.ToString(); &#125;&#125; 当我们将脚本写完保存后，打开 Unity 编辑器在我们的 Player 物体中 GameController 脚本下方的 Bang 处添加我们 Prefabs 文件下的爆炸文件后运行，当我们游戏结束时会发现我们的 Player 物体爆炸了，但是我们下方会有红色文字报错。 它的意思大体为 物体已经被销毁了，但是游戏依旧还在使用它 ，然后在找到下面的提示可以看到问题出现在了我们的 CameraController 文件中的第18行，我们顺着找过去看到的是我们用来使我们的相机位置为 Player 位置加上一个固定值的代码，找到了病因我们就去解决了。 脚本文件名：CameraController 代码如下： 1234567891011121314151617181920212223using System.Collections;using System.Collections.Generic;using UnityEngine;public class CameraController : MonoBehaviour &#123; public GameObject player; private Vector3 offset; private void Awake() &#123; offset = transform.position - player.transform.position; &#125; private void Update() &#123; if (null != player) &#123; transform.position = player.transform.position + offset; &#125; &#125;&#125; 解决方法很简单就是将我们的相机位置代码放在一个 if 判断语句中就行了，判断的条件就是我们的 Player 物体存在就行了。 总结以上就是这篇文章中的所有内容了，因为本人还是新手所以在很多内容上理解可能很不准确或者错误的，希望各位朋友能像我提出，我一定会悉心学习并改正的，我也会努力让自己与目标更加靠近的！！！ 欢迎大家收藏我的博客，我会努力更新更多的作品的，给自己加个油！]]></content>
      <categories>
        <category>教程</category>
        <category>Unity</category>
        <category>官方案例进阶</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>官方案例</tag>
        <tag>Roll a ball</tag>
        <tag>进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity官方案例--Roll a ball]]></title>
    <url>%2F2018%2F11%2F15%2FUnity%E5%AE%98%E6%96%B9%E6%A1%88%E4%BE%8B-Roll-a-ball%2F</url>
    <content type="text"><![CDATA[现在的我还是一名 Unity3d 游戏开发初学者，所以现在都在围绕 Unity3d 的官方案例来做练习，为此写下一些文章作为笔记，文章中难免会有一些疏漏，有些不当之处还望指正。 项目简介首先玩家可以控制一个小球，去吃那些悬浮在平面上的小方块，全部吃玩就游戏结束了，是一个很简单的小游戏。 创建工程首先我们创建一个空的工程 环境搭建创建地面在 Hierarchy 界面中右键选择 3D Object 中的 Plane 创建一个地面，其中将他 Inspector 界面中的 Scale(X:2,Y:1,Z:2)使地面扩大一下，这里需要让大家养成一个好的习惯就是物体的需要命名并且要有意义，所以我将我们的 Plan物体名改为 Ground。 给地面添加材质但由于这地面太白了，再加上默认的灯光效果很亮表现得很刺眼，所以我给地面添加了一个黑色的材质，这里有需要大家养成一个文件分类的好习惯，所以我在我们的 Assets 文件夹中新建了一个 Materials 文件夹用来存放我们需要用到的材质文件，选中 Materials 文件夹后右键选择 Create 选项中选择 Material 就可以创建一个材质文件了，我将它改名为 Ground，其中在他的 Inspector 界面中将 Main Maps 中的 Albedo 的颜色调整为黑色，最后只需将这个材质文件拖到我们场景中的地面上即可。 添加墙在 Hierarchy 界面中右键选择 3D Object 中的 Cube 来创建四周的墙，其中在它们的 Inspector 界面中都设置 Scale(X:21,Y:1,Z:1)，它们的位置分别设置为 Wall[Positon(X:0,Y:0,Z:10)], Wall1[Positon(X:0,Y:0,Z:-10)], Wall2[Position(X:10,Y:0,Z:0),Rotation(X:0,Y:90,Z:0)], Wall3[Position(X:-10,Y:0,Z:0),Rotation(X:0,Y:90,Z:0)] 这里又有一点需要大家养成的习惯就是若有相同的物体应该创建一个空的物体将他们都存放在你里面，所以我在 Hierarchy 中创建了一个空的物体改名为 Walls 将这四个墙存放在其中。 设置摄像机选择我们场景中的 Main Camera 设置它的 Position(X:0,Y:10,Z:-10),Rotation(X:45,Y:0,Z:0)即可。 添加 Player在 Hierarchy 界面中右键选择 3D Object 中选择 Sphere 将它改名为 Player，设置它的 Position(X:0,Y:0.5,Z:0) 添加 Pick Up在 Hierarchy 界面中右键选择 3D Object 中选择 Cube 将他改名为 Pickup ，其中几个比较关键的设置是 Position 的y的值最好要大于1因为过低 他会卡在地面里，Rotation(X:45,Y:45,Z:45)，还有一个特别关键的就是将 Box Collider 中的 Is Trigger 勾上，它的作用是做触发器，简单来说就是就是当两个物体发生碰撞不产生碰撞效果，但会触发碰撞事件(如果还不能理解，自己在 Unity 中实验一下)，然后就是多创建几个 Pick Up 位置你们随便放，不过这里也有一个方法方便我们创建多个相同的物体并且还可以同步之后需要更改的设置，那就是创建 Prefab。我们在 Assets 文件夹中创建一个 Prefabs 文件夹，将我们创建的 Pickup物体拖至此文件夹，当我们看到 Pickup 物体的名称变蓝后，这就意味着我们的 prefab 创建完成，当我们需要创建 Pickup 物体时，现在只需将 prefab 中的 Pickup 拖至我们的场景中即可创建，然后就是创建一个空的物体改名为 Pickups 用来存放我们创建的 Pickup 。 在 Inspector 界面中找到 Tag 选项后单机再选择选项中最下方的 Add Tag… 后会来到我们的 Tags &amp; Layers 界面，在下方会看见一个 + 标志后单机在输入框中输入 PickUp 后选择 Sa7e 后即可添加标签 添加 UI在 Hierarchy 界面中右键选择 UI 后再选择 Text 选项就可以添加我们的 UI 了，我们将创建出来的 Text 文件改名为 CountText，我们可以在 Inspector 界面中的 Text(Script) 中调整文字内容、字体、字体大小、颜色等多种属性，我们必须要做的是将文本默认的内容给删掉就行了，其他的设置看自己喜好了，但我们要将它至于界面的左上角该如何操作呢？我们可以在 Rect Transform 中看到一个田字格，我们单机一下它就会出现很多位置选项，但是并没有我们所需要的左上角，这时候我们只需要一直按住键盘上的 Alt 键就会发现上面的位置选项发生了变化，之后就可以很明显的看到左上角的选项然后我们选择它就可以了，然后在 Canvas 文件夹下在创建一个 Text 改名为 WinText 用来存储我们的胜利文本的，也要将文本内容删去，位置居中默认就行了，其他设置自定义。 游戏运行从这儿起就要开始我们的脚本编写了，现在 Unity3D 主流脚本编辑语言是 C#，不过像我现在用的 Unity 3D 2018.2的版本脚本语言只剩下了 C#，所以推荐大家写脚本还是用 C# 来编写，学过的朋友理解起来就很方便了，没学过的朋友可以从网上找找相关教学视频了解一下，不过有一点编程经验的其实理解起来还是很简单的，我会在下面脚本中写下相应注释的，方便一些初学者理解的。 Unity官方有一个脚本文档，在遇到什么不懂得问题或者需要完成什么操作脚本忘了怎么写时可以进行查阅。 Unity官方脚本文档 Player 的移动选择我们的 Player 物体文件，在 Inspector 的下方点击 Add Component 在其中的输入框中输入 Rigidbody 回车确定选择，即可给我们的 Player物体添加刚体组件，刚体组件的用处就是给物体添加物理属性的，其中我们将 Angular Drag 的值改为0，意思是取消小球的摩擦力。 还是点击 Add Component 在输入框中输入 PlayerController 选择 New script 再点击下方的 Create and Add 即可给我们的 Player 挂载脚本了，然后我在我们的 Assets 文件夹中创建一个 Scripts 文件夹用来存储我们游戏中的所有用到的脚本文件，将我们刚刚创建的脚本文件拖进此文件夹。 双击我们的脚本文件，就打开了我们默认的脚本编辑器来编辑我们的脚本，我使用的是 visual studio 2017。 下面就开始编辑我们的脚本，来完成小球 Player 的移动。 脚本文件名：PlayerController 代码如下：12345678910111213141516171819202122232425using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerController : MonoBehaviour &#123;//public 公共的，会使此变量显示在 unity 编辑器中方便我们调节数值//此处定义一个 speed 变量是为了控制 Player 的运动速度public float speed;public void FixedUpdate()&#123; //获取横向要使 Player 位移的量 float moveHorizontal = Input.GetAxis("Horizontal"); //获取纵向要使 Player 位移的量 float moveVertical = Input.GetAxis("Vertical"); //定义一个新的三维向量，来确定 Player 的运行方向 Vector3 movement = new Vector3(moveHorizontal, 0.0f, moveVertical); //给 Player 添加一个力使其运动，力的大小我们可以在 Unity 编辑器中编辑 //这里再乘以一个Time.deltaTime是为了使 Player 完成的是每秒移动 speed 米，而不是每帧 speed 米，你们可以试试将这个Time.detalTime删去后 Player 的运行效果 GetComponent&lt;Rigidbody&gt;().AddForce(movement * Time.deltaTime * speed); &#125;&#125; 脚本写完后记得保存一下，再来到我们的 Unity 编辑器中，选择 Player 物体后你会发现在脚本中多出来一个 Speed 项，这就是我们之前定义它为 public 公共项的作用了，我们将他设置值为120，然后点击 Unity 编辑器上方的播放按钮运行，之后我们就可以按 W、A、S、D 键来控制我们的 Player 运动了。 相机跟随让相机跟随 Player 一起运动，使相机和物体为关联关系但不是父子级别的关系，若是父子关系由于 Player 是球体运动时会滚动，所以相机也会随着 Player 的滚动而滚动，这不是我们需要的效果。 选择 Main Camera 物体用上文同样的方法添加 CameraController 脚本文件，然后拖至 Scripts文件夹中存放，双击脚本文件进行编辑。 脚本文件名：Camera Controller 代码如下：123456789101112131415161718192021222324using System.Collections;using System.Collections.Generic;using UnityEngine;public class CameraController : MonoBehaviour &#123;//创建一个公共的游戏物体，在Unity编辑器中可以将一个物体拖至脚本处的 player 的框中，脚本中就可以直接获取此物体，就不需要查找的步骤//此处的功能就是将我们需要摄像机跟随的物体添加进去，也就是 Playerpublic GameObject player;//创建一个变量，用来存储摄像机与物体 Player 未知的默认的差值private Vector3 offSet;private void Start()&#123; //我们给 offSet 赋值，值的的大小为摄像机的 Position 三维向量的值减去 物体 Position 三维向量的值，也就是相机与物体之间的距离 offSet = transform.position - player.transform.position;&#125;private void LateUpdate()&#123; //使我们的相机的位置永远位于物体的位置+ offSet 这个差值 transform.position = player.transform.position + offSet;&#125;&#125; 脚本编写完后我们来到 Unity3D编辑器，选择 Main Camera 物体文件后会发现在脚本下方出现了一个叫 Player 的项，我们可以吧 Player 物体拖至后方的框子中，然后运行移动 Player 就会发现摄像机也在跟随着 Player 一起运动。 Pick Up 的自转这次我们要完成的是将 Pick Up 旋转起来。 选择 Prefabes 中的 Pickup 物体，添加名为 Rotation 的脚本文件后拖至 Scripts 文件夹中，然后双击我们的脚本文件编辑我们的脚本。 脚本文件名： Rotation 代码如下：12345678910using System.Collections;using System.Collections.Generic;using UnityEngine;public class Rotation : MonoBehaviour &#123;private void FixedUpdate()&#123; transform.Rotate(new Vector3(15, 30, 45) * Time.deltaTime);&#125;&#125; 回到 Unity 编辑器运行我们的游戏就可以看到 Pickup 开始自己转了起来。 UI 的控制打开我们的 PlayerController 脚本，我们在其中编辑 UI 的控制脚本。 脚本文件名：PlayerController 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869using System.Collections;using System.Collections.Generic;using UnityEngine;//切记一定要调用 UIusing UnityEngine.UI;public class PlayerController : MonoBehaviour &#123;//public 公共的，会使此变量显示在 unity 编辑器中方便我们调节数值//此处定义一个 speed 变量是为了控制 Player 的运动速度public float speed;//获取我们创建的 CountTextpublic Text countText;//获取我们的创建的 WinTextpublic Text winText;//定义个变量记录我们的得分private int count;public void Start()&#123; //调用我们的自定义函数 SetCount SetCount(); //初始化我们的winText里的文本为空，功能相当于隐藏了此文本 winText.text = "";&#125;public void FixedUpdate()&#123; //获取横向要使 Player 位移的量 float moveHorizontal = Input.GetAxis("Horizontal"); //获取纵向要使 Player 位移的量 float moveVertical = Input.GetAxis("Vertical"); //定义一个新的三维向量，来确定 Player 的运行方向 Vector3 movement = new Vector3(moveHorizontal, 0.0f, moveVertical); //给 Player 添加一个力使其运动，力的大小我们可以在 Unity 编辑器中编辑 //这里再乘以一个Time.deltaTime是为了使 Player 完成的是每秒移动 speed 米，而不是每帧 speed 米，你们可以试试将这个Time.detalTime删去后 Player 的运行效果 GetComponent&lt;Rigidbody&gt;().AddForce(movement * Time.deltaTime * speed);&#125;private void OnTriggerEnter(Collider other)&#123; //当 Player 碰到了物体的 Tag 名为 PickUp 的物体时运行 if 的程序 //为何要加 Tag呢？因为 Player 在运行中会碰到很多东西，比如：地面、墙壁，这些都不是我想要销毁的物体，所以我们给我们需要销毁的物体添加个“名字” if (other.gameObject.tag == "PickUp") &#123; //销毁 Pickup Destroy(other.gameObject); //分数+1 count += 1; //更新 CountText 的文本内容 SetCount(); //当我们的分数大于我们定义的 Pickup 的个数(因为我创建了8个 Pickup，所以我的是 count &gt;= 8) if (count &gt;= 8) &#123; //给我们的 WinText 的文本内添加获胜内容，其功能也就是显示获胜信息 winText.text = "You Win!"; &#125; &#125;&#125;public void SetCount()&#123; //使我们的 CountText 显示分数，其格式为 Count：[分数] countText.text = "Count:" + count;&#125;&#125; 保存我们的代码并打开 Unity 编辑器，选择 Player 物体后将我们的创建的 CountText 和 WinText 物体拖至 PlayerCOntroller 脚本下方相对应的地方，然后运行我们的游戏，此时我们的 Roll a ball 的游戏已经制作完成了。 总结 我们写完代码一定要记得将我们需要使用到的物体挂上，不然运行时没有效果或者报错。 Tag 的添加一定要注意自己的大小写，在脚本添加中判断物体的 Tag 时一定要与我们创建的 Tag 完全一样。 其中游戏的实现可能会有很多种方法，自己可以翻阅 Unity 官方的脚本文档然后去尝试使用其他的一些方法来实现我们的游戏。 如果自己有能力，可以尝试改编游戏加入自己的想法，然后一一去实现它，这样对于我们的游戏开发很有帮助。 游戏开发其实很简单，但是如果想要真正的在这个领域成为“大牛”级别的人物，还需要很多很多的努力，我们一起坚持，一起努力！ 欢迎大家收藏我的博客，我会努力更新更多的作品的，给自己加个油！]]></content>
      <categories>
        <category>教程</category>
        <category>Unity</category>
        <category>官方案例</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>官方案例</tag>
        <tag>Roll a ball</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atom 插件备份--Sync Setting]]></title>
    <url>%2F2018%2F11%2F15%2FAtom-%E6%8F%92%E4%BB%B6%E5%A4%87%E4%BB%BD-Sync-Setting%2F</url>
    <content type="text"><![CDATA[当我们使用的 Atom 插件装的越来越多，相关的配置也越来越个性化，一旦我们的电脑重装后就需要重新安装我们的开发环境，这将会是一件令人头疼的事情，但是现在我发现了一款备份的插件推荐给大家，它就是–Sync Setting。 安装打开我们的 Atom 在菜单栏 File 中找到 Settings 选项，选中的 Install 界面中搜索 Sync Setting 插件，然后点击 install 下载即可,之后可以在 Packages 中找打我们下载的所有插件。 配置 首先我们打开 Sync Setting 的插件配置界面看到，我们需要填写两个内容才可以备份，下面我就一步一步的教大家如何去完成。 第一步：创建 personal access token 打开我们的 GitHub，点击我们的头像选择 Settings 选项，在 Settings 界面中选择 Developer Settings，然后就看到我们需要找到的 Personal access tokens,然后点击右上角的 Generate new token 创建。 注：一定要记得勾选gist选项 点击左下角的 Generate token 创建，然后复制生成的 token 序列粘贴到 Sync Setting 配置界面图中的第一个输入框中。 第二步：创建 gist 还是点击我们的头像，选择 Your gists 后在输入框中随便输入点信息，然后点击 Create secret gist 创建一个gist。 gist创建成功后，我们复制生成的 gistID 将其粘贴到Sync Setting 配置界面图中的第二个输入框中。 以上就是我们的 Sync Setting 所有的配置操作了，那我们该如何备份呢？ 注：最好将两个数据备份一下，以便以后恢复用到。若没有备份需要恢复，可以看文章最下方的教程 备份打开我们 Atom 的文档编辑页面（Crtl + Shift + P），在其中输入”Syn”选中第二个 Backup 选项就可以开始备份了。 ../imgs/img_01/img07.png当 Atom 编辑器右上角出现绿色的备份成功的提示消息，就意味着我们的备份成功啦。 恢复(备份)在新的 Atom 编辑器中下载 Sync Setting 插件，在其配置界面中将我们备份的两个数据分别填入两个输入框中，打开我们 Atom 的文档编辑页面（Crtl + Shift + P），在其中输入”Syn”选中第三个 Restore 选项就可以恢复了。 恢复(未备份)我们缺的就是两个数据就可以完成ifu操作了，所以我们只需要想方法获取到这两个数据就可以了。 personal access token打开我们的 GitHub 找到我们之前创建的 personal access token(在Settings中,前面写的很详细)，然后会看到有个红色字体的按钮，它的意思是重新生成令牌，我们就可以重新生成一个令牌。 GistID打开我们的 GitHub 还是选择 Your gists 到达我们的 gist 的界面，然后选择我们的右上角的 See all of your gists ，找到我们之前创建的 gist。 然后我们点击 init.coffee，就到达了我们备份 Atom 插件信息的一个库. 之后我们以发现我们所需要的 gistID 就在我们的网址结尾处，直接将他复制过去即可。 现在我们所需要的两个数据全都有了，就可以开始我们的恢复操作了，不过在此还是推荐各位朋友记得备份一下，免得花这么多时间去找。 欢迎大家收藏我的博客，我会努力更新更多的作品的，给自己加个油！]]></content>
      <categories>
        <category>教程</category>
        <category>Atom</category>
        <category>Sync Setting 备份插件</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Atom</tag>
        <tag>插件</tag>
        <tag>Sync Setting</tag>
        <tag>备份</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 的使用]]></title>
    <url>%2F2018%2F11%2F15%2FMarkdown%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Markdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 Markdown语法介绍段落与换行Markdown 中的段落指连续的一段文字，编写时段落之间用至少一个空行隔开，段落内多个空格将被视为一个空格，段首不支持缩进。 如果想要在显示时显示多个空行，可以插入 &lt;br/&gt; 来实现，注意的是，插入的 &lt;br/&gt; 应与前后的段落中间至少空一行。 标题这是最为常用的格式，在平时常用的的文本编辑器中大多是这样实现的：输入文本、选中文本、设置标题格式。 12345678910111213Markdown支持两种类型的标题,例如：//类型 1这是一级标题==========这是二级标题----------//类型 2# 这是一级标题## 这是二级标题...###### 这是六级标题 从上面可以看出类型 1 是在标题下面插入 \= 或者 - 来标识标题等级，但局限是其只能表示两个级别的标题。 类型 2 是在标题前面插入 1 - 6 个 # ，表示 6 个等级的标题，这是比较推荐的用法。 注：# 和「一级标题」之间建议保留一个字符的空格，这是最标准的 Markdown 写法。 列表列表格式也很常用，在 Markdown 中，你只需要在文字前面加上 -、+或 * 就可以了，例如：123- 文本1- 文本2- 文本3 上面的 - 可以用 +、*替换。需要注意的是，- 等符号与后面的文字至少空一格空格。 如果你希望有序列表，也可以在文字前面加上 1. 2. 3. 就可以了，例如：1231. 文本12. 文本23. 文本3 同无序列表一样，标记符号与后面的文字至少空一格空格。但编辑时的数字对显示无影响。 代码区块缩进 4 个空格，需要注意的是，每行代码都需要至少缩进 4 个空格，不能像段落一样采用首行标记的偷懒写法，一个代码区会一直持续到没有缩进 4 个空格的那一行。 也可以用一对三个连续的撇号 ` 来包裹代码段，例如：1这是一个代码区块。 有的解释器还能根据代码的语言从而给代码加上语法高亮，例如： 1function func() &#123;&#125; 分割线使用三个及以上的 *、 -或 _来表示一个分割线，符号不能混用，符号之间可以插入多个空格。需要注意的是，使用 - 来插入分割线时需要与上一个段落至少空一行，否则 Markdown 会将上一行文字解释为二级标题。 表格表格是 Markdown 比较复杂的一种表示，例如：12345| Table | Col1 | Col2 || ----- |:----:| ----:|| Row1 | 1-1 | 1-2 || Row2 | 2-1 | 2-2 || Row3 | 3-1 | 3-2 | 注：上面第二行中的点代表对齐方式，分别是默认（居左）、居中、居右。 超链接Markdown 中有三种方式实现超链接,例如： 12//方式 1[百度](http://www.baidu.com) 方式 1 较为常用，也可以为链接的文字加上提示文字，只要在括号中超链接加上空格后添加提示内容即可，例如： 1[百度](http://www.baidu.com "这是提示文字") 方式 2 由链接文字和链接地址组成，不同的是两者均由 [] 包裹。链接地址的格式为： 方括号，里面输入链接地址； 紧接着是一个冒号； 冒号后面至少一个空格； 链接地址； 若有提示文字，空格后用引号或者括号包裹提示文字。 下面是完整示例：123//方式 2[百度][Baidu-url][Baidu-url]: http://www.baidu.com 第三种方式是用 \&lt;&gt; 来包裹 URL。 12//方式 3&lt;http://www.baidu.com&gt; 加粗和斜体Markdown 使用 * 和 _ 来表示粗体和斜体,例如：1234567//加粗**这是加粗文字**__这也是加粗文字__//斜体*这是斜体文字*_这也是斜体文字_ 被偶数个 * 或 _ 包裹的文字显示加粗效果，被奇数个包裹的为倾斜效果。 需要注意的是，* 和 - 要成对出现，不能混合使用，也不能只出现一个。同时，标识符号要与标识的文字紧挨着，符号与符号之间、符号文字之间不能有任何空格。 代码使用 ` (撇号) 来包裹一小段代码，例如：1'hello world' 若想在代码中添加撇号，可以使用多个撇号包裹里面需要添加的撇号，但注意里面的连续的撇号数量不能超过外面的数量,例如:12//显示一个撇号`` ` `` 图片图片的插入方式跟超链接前两种插入方式类似，例如：123456//方式 1![如果图片不能显示，就显示这段文字](图片 url)//方式 2![如果图片不能显示，就显示这段文字][Image-url][Image-url]: 图片url "这是提示文字" 反斜杠我们经常需要在文章中插入一些特殊符号，而这些符号恰好是前面所讲的标识符号，可以在特殊符号前插入 \ 来直接显示符号，而不让 Markdown 来将其解释为标识符号。 Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：123456789101112\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 Markdown编辑器支持Markdown的编辑器有好多，功能也不完全一致，有的是用来进行基本的写作，有的是用来写代码的，有的甚至只是博客平台配套的编辑器。 我个人用过一个都很不错，在这儿推荐一下 windows Markdown Pad 2（Pro版要收费，网上有注册码） Atom （个人主推，免费，颜值高，还可以安装各式各样的插件） Mac MacDown 欢迎大家收藏我的博客，我会努力更新更多的作品的，给自己加个油！]]></content>
      <categories>
        <category>教程</category>
        <category>Markdown语法</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>语法</tag>
        <tag>教程</tag>
      </tags>
  </entry>
</search>
