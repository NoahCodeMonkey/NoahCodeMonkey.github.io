<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Unity官方案例进阶--Roll a ball]]></title>
    <url>%2F2018%2F11%2F15%2F2018-11-15-Unity%E5%AE%98%E6%96%B9%E6%A1%88%E4%BE%8B%E8%BF%9B%E9%98%B6-Roll-a-ball%2F</url>
    <content type="text"><![CDATA[简介 经过上一次的学习，我又想改进一下这款 Roll a ball 游戏，首先这款游戏只有胜利没有失败，所以我想定义一个条件来控制它的输赢，因此我想到了如下的方案：使我们的玩家控制 Player 在规定时间内达到一定的分数就胜利，反之则失败 任务目标这里只是大概的目标内容，还有一些细节会在后面完成的时候体现出来。 完成 PickUp 的随机刷新出现，每隔3秒刷新一个 做一个倒计时器用于显示游戏剩余时间 控制分数和时间，若玩家在规定时间内达到分数则显示 You Win！字样，Player 禁止移动；若失败，则小球爆炸并显示 Game Over！ 字样。 环境搭建主体还是 Roll a ball 的内容，其中有一些小改动，我们在此完成一下。 删除场景中的所有 PickUp因为我们要完成的是随机刷新 PickUp 物体，所以我们不需要在场景中添加 PickUp 物体，到时候会用到一个新的知识来完成我们的随机显示 PickUp 物体的操作。 添加倒计时文本因为我们需要让玩家知道游戏的剩余时间，所以我们需要添加一个用来显示时间的文本，位置我选择在了中间顶部的位置，其他设置随意。 细节修改因为最终我们显示的文本不再是只有胜利，所以将我们之前创建的 WinText 改名为 ResultText。 遗漏补充在官方的案例中，PickUp 是有一个黄色的材质，而我在之前做的项目中忘记添加了，所以我现在添加了一个黄色材质球给我们的 PickUp。 以上就是我们的环境搭建相关的操作，下面就要开始我们的脚本编写，来实现游戏的运行了。 游戏运行修改以及准备我将 PlayerController 中除了将 Player 运动的脚本其余的都删除了。 脚本文件名：PlayerController 代码如下： using System.Collections; using System.Collections.Generic; using UnityEngine; public class PlayerController : MonoBehaviour { public float speed; private float moveHorizontal; private float moveVertical; private Vector3 movement; private void FixedUpdate() { moveHorizontal = Input.GetAxis(&quot;Horizontal&quot;); moveVertical = Input.GetAxis(&quot;Vertical&quot;); movement = new Vector3(moveHorizontal, 0.0f, moveVertical); GetComponent&lt;Rigidbody&gt;().AddForce(movement * speed * Time.deltaTime); } } 我将剩下的代码贴在上方了，有不清楚的或者项目删除了的可以直接复制过去。 创建 GameController 脚本还是在我们的 Player 物体上添加脚本取名为 GameController ，我定义它用来控制整个游戏的运行脚本，其实我们游戏的改变主要就是体现在此脚本的编写，所以当我们完成此脚本的编写也就意味着我们游戏的完成，废话不多说了下面我们就来完成它。 删除补回因为我们将原来 PlayerController 脚本中除了控制小球运动的代码都删除了，所以需要先补充一下 Planyer 与 PickUp 的碰撞以及分数控制的相关代码，此时只是补回后面还会有更改。 脚本文件名：GameController 代码如下： 123456789101112131415161718192021222324252627282930313233343536using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class GameController : MonoBehaviour &#123; public Text countText; private int count; private void Awake() &#123; count = 0; &#125; private void Start() &#123; SetCount(); &#125; private void OnTriggerEnter(Collider other) &#123; if (other.gameObject.tag == "PickUp") &#123; Destroy(other.gameObject); count++; SetCount(); &#125; &#125; void SetCount() &#123; countText.text = "Count:" + count; &#125;&#125; 目标一：刷新 PickUp 物体在此我们要完成的是让我们的 PickUp 物体在地面上的随机位置每3秒刷新一个。 这其中我们会用到几个新的知识，有需要的话最好还是去网上找找资料了解一下或者翻阅官网的API。 Clone 克隆物体 Randam 随机类 脚本文件名：GameController 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class GameController : MonoBehaviour &#123; public Text countText; //用于添加 PickUp 物体，之后克隆要用 public GameObject pickUp; private int count; //定义一个三维向量的值用于存储克隆物体的位置 private Vector3 newPickUpPt; //定义一个需要等待克隆物体的时间，根据目标应该赋值为3 private float fireRate; //定义一个下一次克隆物体的时间 private float nextFire; private void Awake() &#123; count = 0; //给 fireRate 赋值，控制克隆物体的间隔时间 fireRate = 3f; &#125; private void Start() &#123; SetCount(); &#125; private void Update() &#123; //判断游戏时间是否大于我们需要的它克隆的时间 if (Time.time &gt; nextFire) &#123; //计算下一次克隆时的时间 nextFire = Time.time + fireRate; //给我们的 PickUp 随机一个位置 newPickUpPt = new Vector3(Random.Range(-8, 8), 1f, Random.Range(-8, 8)); //这就是克隆的操作脚本了 //Instantiate(需要克隆的物体，克隆物体的 Pothion 值，克隆物体的 Rotation值) //此处我们要克隆的物体是 PickUp，他的位置就是我们之前随机存储的那个位置，Quaternion.identity 的意思是与原物体的 Rotation 值保持不变 Instantiate(pickUp, newPickUpPt, Quaternion.identity); &#125; &#125; private void OnTriggerEnter(Collider other) &#123; if (other.gameObject.tag == "PickUp") &#123; Destroy(other.gameObject); count++; SetCount(); &#125; &#125; void SetCount() &#123; countText.text = "Count:" + count; &#125;&#125; 脚本我们现在就写完了，保存一下脚本，然后来到我们的 Unity 编辑器中，给我们 Player 物体中的 GameController 脚本中的 Player 物体添加一下，然后运行就可以看到 PickUp 开始有规律的创建了。 控制倒计时器做倒计时器又需要用到一个新的知识–协程，这个知识还是很重要的，最好先去翻阅些资料了解一下它。 脚本文件名：GameController 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class GameController : MonoBehaviour &#123; public Text countText; //用于添加时间 Text 物体 public Text timeText; //用于添加 PickUp 物体，之后克隆要用 public GameObject pickUp; private int count; //定义一个三维向量的值用于存储克隆物体的位置 private Vector3 newPickUpPt; //定义一个需要等待克隆物体的时间，根据目标应该赋值为3 private float fireRate; //定义一个下一次克隆物体的时间 private float nextFire; private float time; private void Awake() &#123; count = 0; //给 fireRate 赋值，控制克隆物体的间隔时间 fireRate = 3f; time = 8; &#125; private void Start() &#123; SetCount(); //开始我们的协程 StartCoroutine(Timer()); &#125; private IEnumerator Timer() &#123; //定义一个循环，条件为要time&gt;0 while (time &gt; 0) &#123; //间隔1秒继续执行一下代码 yield return new WaitForSeconds(1); //time自减1 time--; //更新我们的时间文本 SetTime(); &#125; //结束我们的协程 StopCoroutine(Timer()); &#125; private void Update() &#123; //判断游戏时间是否大于我们需要的它克隆的时间 if (Time.time &gt; nextFire) &#123; //计算下一次克隆时的时间 nextFire = Time.time + fireRate; //给我们的 PickUp 随机一个位置 newPickUpPt = new Vector3(Random.Range(-8, 8), 1f, Random.Range(-8, 8)); //这就是克隆的操作脚本了 //Instantiate(需要克隆的物体，克隆物体的 Pothion 值，克隆物体的 Rotation值) //此处我们要克隆的物体是 PickUp，他的位置就是我们之前随机存储的那个位置，Quaternion.identity 的意思是与原物体的 Rotation 值保持不变 Instantiate(pickUp, newPickUpPt, Quaternion.identity); &#125; &#125; private void OnTriggerEnter(Collider other) &#123; if (other.gameObject.tag == "PickUp") &#123; Destroy(other.gameObject); count++; SetCount(); &#125; &#125; void SetCount() &#123; countText.text = "Count:" + count; &#125; void SetTime() &#123; timeText.text = time.ToString(); &#125;&#125; 控制结果方法挺多的，可以自己想想怎么去完成。 脚本文件名：GameController 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class GameController : MonoBehaviour &#123; public Text countText; //用于添加时间 Text 物体 public Text timeText; public Text resultText; //用于添加 PickUp 物体，之后克隆要用 public GameObject pickUp; private int count; //定义一个三维向量的值用于存储克隆物体的位置 private Vector3 newPickUpPt; //定义一个需要等待克隆物体的时间，根据目标应该赋值为3 private float fireRate; //定义一个下一次克隆物体的时间 private float nextFire; private float time; private void Awake() &#123; count = 0; //给 fireRate 赋值，控制克隆物体的间隔时间 fireRate = 3f; time = 8; &#125; private void Start() &#123; SetCount(); //开始我们的协程 StartCoroutine(Timer()); &#125; private IEnumerator Timer() &#123; //定义一个循环，条件为要time&gt;0 while (time &gt; 0) &#123; //间隔1秒继续执行一下代码 yield return new WaitForSeconds(1); //time自减1 time--; //更新我们的时间文本 SetTime(); //调用我们创建的控制结果函数 if (time &lt;= 0 &amp;&amp; count &lt; 2) &#123; resultText.text = "Game Over!"; &#125; else if (count &gt;= 2) &#123; resultText.text = "You Win!"; &#125; &#125; //结束我们的协程 StopCoroutine(Timer()); &#125; private void Update() &#123; //判断游戏时间是否大于我们需要的它克隆的时间 if (Time.time &gt; nextFire &amp;&amp; time &gt; 0) &#123; //计算下一次克隆时的时间 nextFire = Time.time + fireRate; //给我们的 PickUp 随机一个位置 newPickUpPt = new Vector3(Random.Range(-8, 8), 1f, Random.Range(-8, 8)); //这就是克隆的操作脚本了 //Instantiate(需要克隆的物体，克隆物体的 Pothion 值，克隆物体的 Rotation值) //此处我们要克隆的物体是 PickUp，他的位置就是我们之前随机存储的那个位置，Quaternion.identity 的意思是与原物体的 Rotation 值保持不变 Instantiate(pickUp, newPickUpPt, Quaternion.identity); &#125; &#125; private void OnTriggerEnter(Collider other) &#123; if (other.gameObject.tag == "PickUp") &#123; Destroy(other.gameObject); count++; SetCount(); &#125; &#125; void SetCount() &#123; countText.text = "Count:" + count; &#125; void SetTime() &#123; timeText.text = time.ToString(); &#125;&#125; 游戏的完善这是我们此游戏的最后部分，用于完善一些游戏中缺乏的地方，也添加了一些比较有意思的东西，来使游戏更加具有趣味性。 完善物体的克隆创建当游戏结束时，我们的克隆还在不停操作，这是我们不愿意看到的，所以接下来我们来完善它。 其实完善很简单，只需在我们克隆创建操作的 if 判断中添加条件就可以了。 脚本文件名：GameController 代码如下： 123456789101112131415private void Update() &#123; //判断游戏时间是否大于我们需要的它克隆的时间 if (Time.time &gt; nextFire &amp;&amp; time &gt; 0) &#123; //计算下一次克隆时的时间 nextFire = Time.time + fireRate; //给我们的 PickUp 随机一个位置 newPickUpPt = new Vector3(Random.Range(-8, 8), 1f, Random.Range(-8, 8)); //这就是克隆的操作脚本了 //Instantiate(需要克隆的物体，克隆物体的 Pothion 值，克隆物体的 Rotation值) //此处我们要克隆的物体是 PickUp，他的位置就是我们之前随机存储的那个位置，Quaternion.identity 的意思是与原物体的 Rotation 值保持不变 Instantiate(pickUp, newPickUpPt, Quaternion.identity); &#125; &#125; 完善倒计时器当我们游戏胜利后会发现我们的倒计时器依旧还在运行，所以这是有问题的，因此接下来我们就来完善它。 来到我们打代码，会发现我们的游戏胜利放在了倒计时器中的循环中，因此只要当我们胜利之后添加一个 个 Break 语句跳出循环就可以完成我们的倒计时停止的操作了。 脚本文件名：GmaeController 代买如下： 12345678910111213141516171819202122232425private IEnumerator Timer() &#123; //定义一个循环，条件为要time&gt;0 while (time &gt; 0) &#123; //间隔1秒继续执行一下代码 yield return new WaitForSeconds(1); //time自减1 time--; //更新我们的时间文本 SetTime(); //调用我们创建的控制结果函数 if (time &lt;= 0 &amp;&amp; count &lt; 2) &#123; resultText.text = "Game Over!"; &#125; else if (count &gt;= 2) &#123; resultText.text = "You Win!"; break; &#125; &#125; //结束我们的协程 StopCoroutine(Timer()); &#125; 写完代码后运行，然后完成我们的两个小球的条件后，会发现我们的倒计时停止了，耶！完成啦！但是我们又会惊喜的发现刚完成的游戏结束后停止创建物体的任务并没有完善，我们只考虑到了游戏失败时停止创建，若当游戏胜利结束时并没有考虑到，所以我们又要回过头来重新完善我们之前的任务。 补：完善物体的克隆创建要完善其实也很简单，只需要在我们创建的条件中再添加一个 Count 要小于我们的目标值就可以了。 脚本文件名： GameController 代码如下： 123456789101112131415private void Update() &#123; //判断游戏时间是否大于我们需要的它克隆的时间 if (Time.time &gt; nextFire &amp;&amp; time &gt; 0 &amp;&amp; count &lt; 2) &#123; //计算下一次克隆时的时间 nextFire = Time.time + fireRate; //给我们的 PickUp 随机一个位置 newPickUpPt = new Vector3(Random.Range(-8, 8), 1f, Random.Range(-8, 8)); //这就是克隆的操作脚本了 //Instantiate(需要克隆的物体，克隆物体的 Pothion 值，克隆物体的 Rotation值) //此处我们要克隆的物体是 PickUp，他的位置就是我们之前随机存储的那个位置，Quaternion.identity 的意思是与原物体的 Rotation 值保持不变 Instantiate(pickUp, newPickUpPt, Quaternion.identity); &#125; &#125; 趣味添加：游戏失败小球爆炸效果爆炸效果是从网上找的，在此感谢TPMer博主提供，爆炸效果需要用到的素材请到他的CSDN博客最底处下载。 TPMerd的CSDN博客 素材下载完成后记住他的下载位置当我们导入时需要用到，再打开我们的 Unity 编辑器在菜单栏中的 Assets 中找到 Import Package 再选择 Custom Package 选项来添加我们的素材，找到我们之前下载的素材包打开，在 Import Unity Package 界面中，我们勾去第一个 000.unity 场景文件后选择右下角的 Import 选项添加我们的素材。 然后编辑我们的脚本文件来完成我们的小球爆炸效果。 脚本文件名：GameController 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class GameController : MonoBehaviour &#123; public Text countText; //用于添加时间 Text 物体 public Text timeText; public Text resultText; //用于添加 PickUp 物体，之后克隆要用 public GameObject pickUp; //用于添加我们的爆炸物体 public GameObject Bang; private int count; //定义一个三维向量的值用于存储克隆物体的位置 private Vector3 newPickUpPt; //定义一个需要等待克隆物体的时间，根据目标应该赋值为3 private float fireRate; //定义一个下一次克隆物体的时间 private float nextFire; private float time; private void Awake() &#123; count = 0; //给 fireRate 赋值，控制克隆物体的间隔时间 fireRate = 3f; time = 8; &#125; private void Start() &#123; SetCount(); //开始我们的协程 StartCoroutine(Timer()); &#125; private IEnumerator Timer() &#123; //定义一个循环，条件为要time&gt;0 while (time &gt; 0) &#123; //间隔1秒继续执行一下代码 yield return new WaitForSeconds(1); //time自减1 time--; //更新我们的时间文本 SetTime(); //调用我们创建的控制结果函数 if (time &lt;= 0 &amp;&amp; count &lt; 2) &#123; resultText.text = "Game Over!"; //将 Player 物体销毁 Destroy(this.gameObject); //克隆我们的爆炸物体来代替我们的 Player 物体 Instantiate(Bang, this.transform.position, this.transform.rotation); &#125; else if (count &gt;= 2) &#123; resultText.text = "You Win!"; break; &#125; &#125; //结束我们的协程 StopCoroutine(Timer()); &#125; private void Update() &#123; //判断游戏时间是否大于我们需要的它克隆的时间 if (Time.time &gt; nextFire &amp;&amp; time &gt; 0 &amp;&amp; count &lt; 2) &#123; //计算下一次克隆时的时间 nextFire = Time.time + fireRate; //给我们的 PickUp 随机一个位置 newPickUpPt = new Vector3(Random.Range(-8, 8), 1f, Random.Range(-8, 8)); //这就是克隆的操作脚本了 //Instantiate(需要克隆的物体，克隆物体的 Pothion 值，克隆物体的 Rotation值) //此处我们要克隆的物体是 PickUp，他的位置就是我们之前随机存储的那个位置，Quaternion.identity 的意思是与原物体的 Rotation 值保持不变 Instantiate(pickUp, newPickUpPt, Quaternion.identity); &#125; &#125; private void OnTriggerEnter(Collider other) &#123; if (other.gameObject.tag == "PickUp") &#123; Destroy(other.gameObject); count++; SetCount(); &#125; &#125; void SetCount() &#123; countText.text = "Count:" + count; &#125; void SetTime() &#123; timeText.text = time.ToString(); &#125;&#125; 当我们将脚本写完保存后，打开 Unity 编辑器在我们的 Player 物体中 GameController 脚本下方的 Bang 处添加我们 Prefabs 文件下的爆炸文件后运行，当我们游戏结束时会发现我们的 Player 物体爆炸了，但是我们下方会有红色文字报错。 它的意思大体为 物体已经被销毁了，但是游戏依旧还在使用它 ，然后在找到下面的提示可以看到问题出现在了我们的 CameraController 文件中的第18行，我们顺着找过去看到的是我们用来使我们的相机位置为 Player 位置加上一个固定值的代码，找到了病因我们就去解决了。 脚本文件名：CameraController 代码如下： 1234567891011121314151617181920212223using System.Collections;using System.Collections.Generic;using UnityEngine;public class CameraController : MonoBehaviour &#123; public GameObject player; private Vector3 offset; private void Awake() &#123; offset = transform.position - player.transform.position; &#125; private void Update() &#123; if (null != player) &#123; transform.position = player.transform.position + offset; &#125; &#125;&#125; 解决方法很简单就是将我们的相机位置代码放在一个 if 判断语句中就行了，判断的条件就是我们的 Player 物体存在就行了。 总结以上就是这篇文章中的所有内容了，因为本人还是新手所以在很多内容上理解可能很不准确或者错误的，希望各位朋友能像我提出，我一定会悉心学习并改正的，我也会努力让自己与目标更加靠近的！！！ 欢迎大家收藏我的博客，我会努力更新更多的作品的，给自己加个油！]]></content>
      <categories>
        <category>教程</category>
        <category>Unity</category>
        <category>官方案例进阶</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>官方案例</tag>
        <tag>进阶，Roll a ball</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity官方案例--Roll a ball]]></title>
    <url>%2F2018%2F11%2F15%2F2018-11-15-Unity%E5%AE%98%E6%96%B9%E6%A1%88%E4%BE%8B-Roll-a-ball%2F</url>
    <content type="text"><![CDATA[现在的我还是一名 Unity3d 游戏开发初学者，所以现在都在围绕 Unity3d 的官方案例来做练习，为此写下一些文章作为笔记，文章中难免会有一些疏漏，有些不当之处还望指正。 项目简介首先玩家可以控制一个小球，去吃那些悬浮在平面上的小方块，全部吃玩就游戏结束了，是一个很简单的小游戏。 创建工程首先我们创建一个空的工程 环境搭建创建地面在 Hierarchy 界面中右键选择 3D Object 中的 Plane 创建一个地面，其中将他 Inspector 界面中的 Scale(X:2,Y:1,Z:2)使地面扩大一下，这里需要让大家养成一个好的习惯就是物体的需要命名并且要有意义，所以我将我们的 Plan物体名改为 Ground。 给地面添加材质但由于这地面太白了，再加上默认的灯光效果很亮表现得很刺眼，所以我给地面添加了一个黑色的材质，这里有需要大家养成一个文件分类的好习惯，所以我在我们的 Assets 文件夹中新建了一个 Materials 文件夹用来存放我们需要用到的材质文件，选中 Materials 文件夹后右键选择 Create 选项中选择 Material 就可以创建一个材质文件了，我将它改名为 Ground，其中在他的 Inspector 界面中将 Main Maps 中的 Albedo 的颜色调整为黑色，最后只需将这个材质文件拖到我们场景中的地面上即可。 添加墙在 Hierarchy 界面中右键选择 3D Object 中的 Cube 来创建四周的墙，其中在它们的 Inspector 界面中都设置 Scale(X:21,Y:1,Z:1)，它们的位置分别设置为 Wall[Positon(X:0,Y:0,Z:10)], Wall1[Positon(X:0,Y:0,Z:-10)], Wall2[Position(X:10,Y:0,Z:0),Rotation(X:0,Y:90,Z:0)], Wall3[Position(X:-10,Y:0,Z:0),Rotation(X:0,Y:90,Z:0)] 这里又有一点需要大家养成的习惯就是若有相同的物体应该创建一个空的物体将他们都存放在你里面，所以我在 Hierarchy 中创建了一个空的物体改名为 Walls 将这四个墙存放在其中。 设置摄像机选择我们场景中的 Main Camera 设置它的 Position(X:0,Y:10,Z:-10),Rotation(X:45,Y:0,Z:0)即可。 添加 Player在 Hierarchy 界面中右键选择 3D Object 中选择 Sphere 将它改名为 Player，设置它的 Position(X:0,Y:0.5,Z:0) 添加 Pick Up在 Hierarchy 界面中右键选择 3D Object 中选择 Cube 将他改名为 Pickup ，其中几个比较关键的设置是 Position 的y的值最好要大于1因为过低 他会卡在地面里，Rotation(X:45,Y:45,Z:45)，还有一个特别关键的就是将 Box Collider 中的 Is Trigger 勾上，它的作用是做触发器，简单来说就是就是当两个物体发生碰撞不产生碰撞效果，但会触发碰撞事件(如果还不能理解，自己在 Unity 中实验一下)，然后就是多创建几个 Pick Up 位置你们随便放，不过这里也有一个方法方便我们创建多个相同的物体并且还可以同步之后需要更改的设置，那就是创建 Prefab。我们在 Assets 文件夹中创建一个 Prefabs 文件夹，将我们创建的 Pickup物体拖至此文件夹，当我们看到 Pickup 物体的名称变蓝后，这就意味着我们的 prefab 创建完成，当我们需要创建 Pickup 物体时，现在只需将 prefab 中的 Pickup 拖至我们的场景中即可创建，然后就是创建一个空的物体改名为 Pickups 用来存放我们创建的 Pickup 。 在 Inspector 界面中找到 Tag 选项后单机再选择选项中最下方的 Add Tag… 后会来到我们的 Tags &amp; Layers 界面，在下方会看见一个 + 标志后单机在输入框中输入 PickUp 后选择 Sa7e 后即可添加标签 添加 UI在 Hierarchy 界面中右键选择 UI 后再选择 Text 选项就可以添加我们的 UI 了，我们将创建出来的 Text 文件改名为 CountText，我们可以在 Inspector 界面中的 Text(Script) 中调整文字内容、字体、字体大小、颜色等多种属性，我们必须要做的是将文本默认的内容给删掉就行了，其他的设置看自己喜好了，但我们要将它至于界面的左上角该如何操作呢？我们可以在 Rect Transform 中看到一个田字格，我们单机一下它就会出现很多位置选项，但是并没有我们所需要的左上角，这时候我们只需要一直按住键盘上的 Alt 键就会发现上面的位置选项发生了变化，之后就可以很明显的看到左上角的选项然后我们选择它就可以了，然后在 Canvas 文件夹下在创建一个 Text 改名为 WinText 用来存储我们的胜利文本的，也要将文本内容删去，位置居中默认就行了，其他设置自定义。 游戏运行从这儿起就要开始我们的脚本编写了，现在 Unity3D 主流脚本编辑语言是 C#，不过像我现在用的 Unity 3D 2018.2的版本脚本语言只剩下了 C#，所以推荐大家写脚本还是用 C# 来编写，学过的朋友理解起来就很方便了，没学过的朋友可以从网上找找相关教学视频了解一下，不过有一点编程经验的其实理解起来还是很简单的，我会在下面脚本中写下相应注释的，方便一些初学者理解的。 Unity官方有一个脚本文档，在遇到什么不懂得问题或者需要完成什么操作脚本忘了怎么写时可以进行查阅。 Unity官方脚本文档 Player 的移动选择我们的 Player 物体文件，在 Inspector 的下方点击 Add Component 在其中的输入框中输入 Rigidbody 回车确定选择，即可给我们的 Player物体添加刚体组件，刚体组件的用处就是给物体添加物理属性的，其中我们将 Angular Drag 的值改为0，意思是取消小球的摩擦力。 还是点击 Add Component 在输入框中输入 PlayerController 选择 New script 再点击下方的 Create and Add 即可给我们的 Player 挂载脚本了，然后我在我们的 Assets 文件夹中创建一个 Scripts 文件夹用来存储我们游戏中的所有用到的脚本文件，将我们刚刚创建的脚本文件拖进此文件夹。 双击我们的脚本文件，就打开了我们默认的脚本编辑器来编辑我们的脚本，我使用的是 visual studio 2017。 下面就开始编辑我们的脚本，来完成小球 Player 的移动。 脚本文件名：PlayerController 代码如下：12345678910111213141516171819202122232425using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerController : MonoBehaviour &#123;//public 公共的，会使此变量显示在 unity 编辑器中方便我们调节数值//此处定义一个 speed 变量是为了控制 Player 的运动速度public float speed;public void FixedUpdate()&#123; //获取横向要使 Player 位移的量 float moveHorizontal = Input.GetAxis("Horizontal"); //获取纵向要使 Player 位移的量 float moveVertical = Input.GetAxis("Vertical"); //定义一个新的三维向量，来确定 Player 的运行方向 Vector3 movement = new Vector3(moveHorizontal, 0.0f, moveVertical); //给 Player 添加一个力使其运动，力的大小我们可以在 Unity 编辑器中编辑 //这里再乘以一个Time.deltaTime是为了使 Player 完成的是每秒移动 speed 米，而不是每帧 speed 米，你们可以试试将这个Time.detalTime删去后 Player 的运行效果 GetComponent&lt;Rigidbody&gt;().AddForce(movement * Time.deltaTime * speed); &#125;&#125; 脚本写完后记得保存一下，再来到我们的 Unity 编辑器中，选择 Player 物体后你会发现在脚本中多出来一个 Speed 项，这就是我们之前定义它为 public 公共项的作用了，我们将他设置值为120，然后点击 Unity 编辑器上方的播放按钮运行，之后我们就可以按 W、A、S、D 键来控制我们的 Player 运动了。 相机跟随让相机跟随 Player 一起运动，使相机和物体为关联关系但不是父子级别的关系，若是父子关系由于 Player 是球体运动时会滚动，所以相机也会随着 Player 的滚动而滚动，这不是我们需要的效果。 选择 Main Camera 物体用上文同样的方法添加 CameraController 脚本文件，然后拖至 Scripts文件夹中存放，双击脚本文件进行编辑。 脚本文件名：Camera Controller 代码如下：123456789101112131415161718192021222324using System.Collections;using System.Collections.Generic;using UnityEngine;public class CameraController : MonoBehaviour &#123;//创建一个公共的游戏物体，在Unity编辑器中可以将一个物体拖至脚本处的 player 的框中，脚本中就可以直接获取此物体，就不需要查找的步骤//此处的功能就是将我们需要摄像机跟随的物体添加进去，也就是 Playerpublic GameObject player;//创建一个变量，用来存储摄像机与物体 Player 未知的默认的差值private Vector3 offSet;private void Start()&#123; //我们给 offSet 赋值，值的的大小为摄像机的 Position 三维向量的值减去 物体 Position 三维向量的值，也就是相机与物体之间的距离 offSet = transform.position - player.transform.position;&#125;private void LateUpdate()&#123; //使我们的相机的位置永远位于物体的位置+ offSet 这个差值 transform.position = player.transform.position + offSet;&#125;&#125; 脚本编写完后我们来到 Unity3D编辑器，选择 Main Camera 物体文件后会发现在脚本下方出现了一个叫 Player 的项，我们可以吧 Player 物体拖至后方的框子中，然后运行移动 Player 就会发现摄像机也在跟随着 Player 一起运动。 Pick Up 的自转这次我们要完成的是将 Pick Up 旋转起来。 选择 Prefabes 中的 Pickup 物体，添加名为 Rotation 的脚本文件后拖至 Scripts 文件夹中，然后双击我们的脚本文件编辑我们的脚本。 脚本文件名： Rotation 代码如下：12345678910using System.Collections;using System.Collections.Generic;using UnityEngine;public class Rotation : MonoBehaviour &#123;private void FixedUpdate()&#123; transform.Rotate(new Vector3(15, 30, 45) * Time.deltaTime);&#125;&#125; 回到 Unity 编辑器运行我们的游戏就可以看到 Pickup 开始自己转了起来。 UI 的控制打开我们的 PlayerController 脚本，我们在其中编辑 UI 的控制脚本。 脚本文件名：PlayerController 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869using System.Collections;using System.Collections.Generic;using UnityEngine;//切记一定要调用 UIusing UnityEngine.UI;public class PlayerController : MonoBehaviour &#123;//public 公共的，会使此变量显示在 unity 编辑器中方便我们调节数值//此处定义一个 speed 变量是为了控制 Player 的运动速度public float speed;//获取我们创建的 CountTextpublic Text countText;//获取我们的创建的 WinTextpublic Text winText;//定义个变量记录我们的得分private int count;public void Start()&#123; //调用我们的自定义函数 SetCount SetCount(); //初始化我们的winText里的文本为空，功能相当于隐藏了此文本 winText.text = "";&#125;public void FixedUpdate()&#123; //获取横向要使 Player 位移的量 float moveHorizontal = Input.GetAxis("Horizontal"); //获取纵向要使 Player 位移的量 float moveVertical = Input.GetAxis("Vertical"); //定义一个新的三维向量，来确定 Player 的运行方向 Vector3 movement = new Vector3(moveHorizontal, 0.0f, moveVertical); //给 Player 添加一个力使其运动，力的大小我们可以在 Unity 编辑器中编辑 //这里再乘以一个Time.deltaTime是为了使 Player 完成的是每秒移动 speed 米，而不是每帧 speed 米，你们可以试试将这个Time.detalTime删去后 Player 的运行效果 GetComponent&lt;Rigidbody&gt;().AddForce(movement * Time.deltaTime * speed);&#125;private void OnTriggerEnter(Collider other)&#123; //当 Player 碰到了物体的 Tag 名为 PickUp 的物体时运行 if 的程序 //为何要加 Tag呢？因为 Player 在运行中会碰到很多东西，比如：地面、墙壁，这些都不是我想要销毁的物体，所以我们给我们需要销毁的物体添加个“名字” if (other.gameObject.tag == "PickUp") &#123; //销毁 Pickup Destroy(other.gameObject); //分数+1 count += 1; //更新 CountText 的文本内容 SetCount(); //当我们的分数大于我们定义的 Pickup 的个数(因为我创建了8个 Pickup，所以我的是 count &gt;= 8) if (count &gt;= 8) &#123; //给我们的 WinText 的文本内添加获胜内容，其功能也就是显示获胜信息 winText.text = "You Win!"; &#125; &#125;&#125;public void SetCount()&#123; //使我们的 CountText 显示分数，其格式为 Count：[分数] countText.text = "Count:" + count;&#125;&#125; 保存我们的代码并打开 Unity 编辑器，选择 Player 物体后将我们的创建的 CountText 和 WinText 物体拖至 PlayerCOntroller 脚本下方相对应的地方，然后运行我们的游戏，此时我们的 Roll a ball 的游戏已经制作完成了。 总结 我们写完代码一定要记得将我们需要使用到的物体挂上，不然运行时没有效果或者报错。 Tag 的添加一定要注意自己的大小写，在脚本添加中判断物体的 Tag 时一定要与我们创建的 Tag 完全一样。 其中游戏的实现可能会有很多种方法，自己可以翻阅 Unity 官方的脚本文档然后去尝试使用其他的一些方法来实现我们的游戏。 如果自己有能力，可以尝试改编游戏加入自己的想法，然后一一去实现它，这样对于我们的游戏开发很有帮助。 游戏开发其实很简单，但是如果想要真正的在这个领域成为“大牛”级别的人物，还需要很多很多的努力，我们一起坚持，一起努力！ 欢迎大家收藏我的博客，我会努力更新更多的作品的，给自己加个油！]]></content>
      <categories>
        <category>教程</category>
        <category>Unity</category>
        <category>官方案例</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>官方案例</tag>
        <tag>Roll a ball</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atom 插件备份--Sync Setting]]></title>
    <url>%2F2018%2F11%2F15%2F2018-11-15-Atom-%E6%8F%92%E4%BB%B6%E5%A4%87%E4%BB%BD-Sync-Setting%2F</url>
    <content type="text"><![CDATA[当我们使用的 Atom 插件装的越来越多，相关的配置也越来越个性化，一旦我们的电脑重装后就需要重新安装我们的开发环境，这将会是一件令人头疼的事情，但是现在我发现了一款备份的插件推荐给大家，它就是–Sync Setting。 安装打开我们的 Atom 在菜单栏 File 中找到 Settings 选项，选中的 Install 界面中搜索 Sync Setting 插件，然后点击 install 下载即可,之后可以在 Packages 中找打我们下载的所有插件。 配置 首先我们打开 Sync Setting 的插件配置界面看到，我们需要填写两个内容才可以备份，下面我就一步一步的教大家如何去完成。 第一步：创建 personal access token 打开我们的 GitHub，点击我们的头像选择 Settings 选项，在 Settings 界面中选择 Developer Settings，然后就看到我们需要找到的 Personal access tokens,然后点击右上角的 Generate new token 创建。 注：一定要记得勾选gist选项 点击左下角的 Generate token 创建，然后复制生成的 token 序列粘贴到 Sync Setting 配置界面图中的第一个输入框中。 第二步：创建 gist 还是点击我们的头像，选择 Your gists 后在输入框中随便输入点信息，然后点击 Create secret gist 创建一个gist。 gist创建成功后，我们复制生成的 gistID 将其粘贴到Sync Setting 配置界面图中的第二个输入框中。 以上就是我们的 Sync Setting 所有的配置操作了，那我们该如何备份呢？ 注：最好将两个数据备份一下，以便以后恢复用到。若没有备份需要恢复，可以看文章最下方的教程 备份打开我们 Atom 的文档编辑页面（Crtl + Shift + P），在其中输入”Syn”选中第二个 Backup 选项就可以开始备份了。 ../imgs/img_01/img07.png当 Atom 编辑器右上角出现绿色的备份成功的提示消息，就意味着我们的备份成功啦。 恢复(备份)在新的 Atom 编辑器中下载 Sync Setting 插件，在其配置界面中将我们备份的两个数据分别填入两个输入框中，打开我们 Atom 的文档编辑页面（Crtl + Shift + P），在其中输入”Syn”选中第三个 Restore 选项就可以恢复了。 恢复(未备份)我们缺的就是两个数据就可以完成ifu操作了，所以我们只需要想方法获取到这两个数据就可以了。 personal access token打开我们的 GitHub 找到我们之前创建的 personal access token(在Settings中,前面写的很详细)，然后会看到有个红色字体的按钮，它的意思是重新生成令牌，我们就可以重新生成一个令牌。 GistID打开我们的 GitHub 还是选择 Your gists 到达我们的 gist 的界面，然后选择我们的右上角的 See all of your gists ，找到我们之前创建的 gist。 然后我们点击 init.coffee，就到达了我们备份 Atom 插件信息的一个库. 之后我们以发现我们所需要的 gistID 就在我们的网址结尾处，直接将他复制过去即可。 现在我们所需要的两个数据全都有了，就可以开始我们的恢复操作了，不过在此还是推荐各位朋友记得备份一下，免得花这么多时间去找。 欢迎大家收藏我的博客，我会努力更新更多的作品的，给自己加个油！]]></content>
      <categories>
        <category>教程</category>
        <category>Atom</category>
        <category>Sync Setting 备份插件</category>
      </categories>
      <tags>
        <tag>Atom</tag>
        <tag>插件</tag>
        <tag>教程</tag>
        <tag>Sync Setting</tag>
        <tag>备份</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 的使用]]></title>
    <url>%2F2018%2F11%2F15%2F2018-11-15-Markdown%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Markdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 Markdown语法介绍段落与换行Markdown 中的段落指连续的一段文字，编写时段落之间用至少一个空行隔开，段落内多个空格将被视为一个空格，段首不支持缩进。 如果想要在显示时显示多个空行，可以插入 &lt;br/&gt; 来实现，注意的是，插入的 &lt;br/&gt; 应与前后的段落中间至少空一行。 标题这是最为常用的格式，在平时常用的的文本编辑器中大多是这样实现的：输入文本、选中文本、设置标题格式。 12345678910111213Markdown支持两种类型的标题,例如：//类型 1这是一级标题==========这是二级标题----------//类型 2# 这是一级标题## 这是二级标题...###### 这是六级标题 从上面可以看出类型 1 是在标题下面插入 \= 或者 - 来标识标题等级，但局限是其只能表示两个级别的标题。 类型 2 是在标题前面插入 1 - 6 个 # ，表示 6 个等级的标题，这是比较推荐的用法。 注：# 和「一级标题」之间建议保留一个字符的空格，这是最标准的 Markdown 写法。 列表列表格式也很常用，在 Markdown 中，你只需要在文字前面加上 -、+或 * 就可以了，例如：123- 文本1- 文本2- 文本3 上面的 - 可以用 +、*替换。需要注意的是，- 等符号与后面的文字至少空一格空格。 如果你希望有序列表，也可以在文字前面加上 1. 2. 3. 就可以了，例如：1231. 文本12. 文本23. 文本3 同无序列表一样，标记符号与后面的文字至少空一格空格。但编辑时的数字对显示无影响。 代码区块缩进 4 个空格，需要注意的是，每行代码都需要至少缩进 4 个空格，不能像段落一样采用首行标记的偷懒写法，一个代码区会一直持续到没有缩进 4 个空格的那一行。 也可以用一对三个连续的撇号 ` 来包裹代码段，例如：1这是一个代码区块。 有的解释器还能根据代码的语言从而给代码加上语法高亮，例如： 1function func() &#123;&#125; 分割线使用三个及以上的 *、 -或 _来表示一个分割线，符号不能混用，符号之间可以插入多个空格。需要注意的是，使用 - 来插入分割线时需要与上一个段落至少空一行，否则 Markdown 会将上一行文字解释为二级标题。 表格表格是 Markdown 比较复杂的一种表示，例如：12345| Table | Col1 | Col2 || ----- |:----:| ----:|| Row1 | 1-1 | 1-2 || Row2 | 2-1 | 2-2 || Row3 | 3-1 | 3-2 | 注：上面第二行中的点代表对齐方式，分别是默认（居左）、居中、居右。 超链接Markdown 中有三种方式实现超链接,例如： 12//方式 1[百度](http://www.baidu.com) 方式 1 较为常用，也可以为链接的文字加上提示文字，只要在括号中超链接加上空格后添加提示内容即可，例如： 1[百度](http://www.baidu.com "这是提示文字") 方式 2 由链接文字和链接地址组成，不同的是两者均由 [] 包裹。链接地址的格式为： 方括号，里面输入链接地址； 紧接着是一个冒号； 冒号后面至少一个空格； 链接地址； 若有提示文字，空格后用引号或者括号包裹提示文字。 下面是完整示例：123//方式 2[百度][Baidu-url][Baidu-url]: http://www.baidu.com 第三种方式是用 \&lt;&gt; 来包裹 URL。 12//方式 3&lt;http://www.baidu.com&gt; 加粗和斜体Markdown 使用 * 和 _ 来表示粗体和斜体,例如：1234567//加粗**这是加粗文字**__这也是加粗文字__//斜体*这是斜体文字*_这也是斜体文字_ 被偶数个 * 或 _ 包裹的文字显示加粗效果，被奇数个包裹的为倾斜效果。 需要注意的是，* 和 - 要成对出现，不能混合使用，也不能只出现一个。同时，标识符号要与标识的文字紧挨着，符号与符号之间、符号文字之间不能有任何空格。 代码使用 ` (撇号) 来包裹一小段代码，例如：1'hello world' 若想在代码中添加撇号，可以使用多个撇号包裹里面需要添加的撇号，但注意里面的连续的撇号数量不能超过外面的数量,例如:12//显示一个撇号`` ` `` 图片图片的插入方式跟超链接前两种插入方式类似，例如：123456//方式 1![如果图片不能显示，就显示这段文字](图片 url)//方式 2![如果图片不能显示，就显示这段文字][Image-url][Image-url]: 图片url "这是提示文字" 反斜杠我们经常需要在文章中插入一些特殊符号，而这些符号恰好是前面所讲的标识符号，可以在特殊符号前插入 \ 来直接显示符号，而不让 Markdown 来将其解释为标识符号。 Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：123456789101112\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 Markdown编辑器支持Markdown的编辑器有好多，功能也不完全一致，有的是用来进行基本的写作，有的是用来写代码的，有的甚至只是博客平台配套的编辑器。 我个人用过一个都很不错，在这儿推荐一下 windows Markdown Pad 2（Pro版要收费，网上有注册码） Atom （个人主推，免费，颜值高，还可以安装各式各样的插件） Mac MacDown 欢迎大家收藏我的博客，我会努力更新更多的作品的，给自己加个油！]]></content>
      <categories>
        <category>教程</category>
        <category>Markdown语法</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>语法，教程</tag>
      </tags>
  </entry>
</search>
